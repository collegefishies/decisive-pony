// File: with_uart.v
// Generated by MyHDL 1.0dev
// Date: Sat Jul 16 16:16:13 2016


`timescale 1ns/10ps

module with_uart (
    clk,
    hex_freq,
    fpga_rx,
    fpga_tx,
    trigger,
    led2
);


input clk;
output [31:0] hex_freq;
reg [31:0] hex_freq;
input fpga_rx;
input fpga_tx;
input trigger;
output [8:0] led2;
reg [8:0] led2;

reg ready;
reg [6:0] sched_len;
wire [31:0] set_freq;
wire [31:0] freq_step;
wire [31:0] time_step;
wire [31:0] hold_time;
reg [7:0] sched_index;
wire reset;
wire notclock;
reg start;
reg done;
reg all_data_received;
wire trigger_reset;
reg [31:0] curr_freq;
reg add;
reg sub;
wire dec_clk;
reg [8:0] incr;
reg [7:0] whichram;
wire [31:0] biggestblock;
reg [1:0] state;
reg [7:0] rx_data;
wire drdy;
reg [7:0] freq_rambus_addr;
reg [7:0] fstep_rambus_addr;
reg [7:0] tstep_rambus_addr;
reg [7:0] hold_rambus_addr;
reg [6:0] freq_rambus_length;
reg [6:0] fstep_rambus_length;
reg [6:0] tstep_rambus_length;
reg [6:0] hold_rambus_length;
wire [31:0] freq_rambus_din;
wire [31:0] fstep_rambus_din;
wire [31:0] tstep_rambus_din;
wire [31:0] hold_rambus_din;
wire [31:0] freq_rambus_dout;
wire [31:0] fstep_rambus_dout;
wire [31:0] tstep_rambus_dout;
wire [31:0] hold_rambus_dout;
wire freq_rambus_clk;
wire fstep_rambus_clk;
wire tstep_rambus_clk;
wire hold_rambus_clk;
wire [6:0] freq_rambus_raddr;
wire [6:0] fstep_rambus_raddr;
wire [6:0] tstep_rambus_raddr;
wire [6:0] hold_rambus_raddr;
wire [6:0] freq_rambus_waddr;
wire [6:0] fstep_rambus_waddr;
wire [6:0] tstep_rambus_waddr;
wire [6:0] hold_rambus_waddr;
wire signed [30:0] m_manager_0_curr_freq;
reg signed [30:0] m_manager_0_set_freq_latch;
reg [29:0] m_manager_0_set_step_f_latch;
reg [29:0] m_manager_0_set_step_t_latch;
reg [29:0] m_manager_0_set_wait_latch;
reg signed [30:0] m_manager_0_set_freq_latch_int;
reg signed [30:0] m_manager_0_set_step_f_latch_int;
reg signed [30:0] m_manager_0_set_wait_latch_int;
reg m_manager_0_frequency_controller_en;
reg m_manager_0_waiter_en;
reg m_manager_0_quit;
reg m_manager_0_start_holding;
reg m_manager_0_quit_turnedon;
reg m_manager_0_start_holding_turnedon;
reg [1:0] m_manager_0_state;
reg m_manager_0_add_o_int;
reg m_manager_0_sub_o_int;
reg m_manager_0_start_time;
reg m_manager_0_t_step_clk;
reg [29:0] m_manager_0_delta_freq;
reg [0:0] m_manager_0_direction;
reg m_manager_0_dec_clk_en;
wire m_manager_0_freq_controller_clk;
wire m_manager_0_waiter_clk;
reg m_manager_0_quitold;
reg m_manager_0_start_holdingold;
reg [29:0] m_manager_0_half_period;
reg [29:0] m_manager_0_t_step_counter;
wire [35:0] m_dec_0_q_int;
reg signed [30:0] m_dec_0_bq_int;
reg [29:0] m_dec_0_increment;
wire uart_0_baud;
wire uart_0_slowbaud;
wire uart_0_slowbaud_rst;
reg uart_0_started;
reg [2:0] uart_0_bauds_held_down;
reg [4:0] uart_0_bits_received;
wire uart_0_drdy_int;
reg uart_0_latch_en;
reg uart_0_drdy1;
reg uart_0_drdy2;
wire [7:0] uart_0_rx_data_int;
reg uart_0_clkdiv_0_clk_new;
reg [7:0] uart_0_clkdiv_0_counter;
reg uart_0_clkdiv_1_clk_new;
reg [2:0] uart_0_clkdiv_1_counter;
wire [7:0] uart_0_shiftreg_0_par_int;
reg uart_0_shiftreg_0_clk_int;
reg bussedram_0_rambus_we;
reg bussedram_1_rambus_we;
reg bussedram_2_rambus_we;
reg bussedram_3_rambus_we;
reg comms_arbiter_0_delayed_reset1;
reg comms_arbiter_0_delayed_reset2;
reg [7:0] comms_arbiter_0_latch_counter;
reg comms_arbiter_0_drdy_turnedon;
reg comms_arbiter_0_drdy_old;
wire pts_controller_0_pts_enable;
wire [49:0] pts_controller_0_amphenol_int;

reg biggestblock_l [0:32-1];
reg m_dec_0_to_subtract [0:9-1];
reg m_dec_0_to_add [0:9-1];
reg [3:0] m_dec_0_q_int_l [0:9-1];
reg uart_0_shiftreg_0_latches [0:8-1];
reg [31:0] bussedram_0_mem [0:128-1];
reg [31:0] bussedram_1_mem [0:128-1];
reg [31:0] bussedram_2_mem [0:128-1];
reg [31:0] bussedram_3_mem [0:128-1];
wire pts_controller_0_amphenol_l [0:50-1];

assign reset = 1'd0;
assign pts_controller_0_pts_enable = 1'd1;

assign biggestblock[31] = biggestblock_l[31];
assign biggestblock[30] = biggestblock_l[30];
assign biggestblock[29] = biggestblock_l[29];
assign biggestblock[28] = biggestblock_l[28];
assign biggestblock[27] = biggestblock_l[27];
assign biggestblock[26] = biggestblock_l[26];
assign biggestblock[25] = biggestblock_l[25];
assign biggestblock[24] = biggestblock_l[24];
assign biggestblock[23] = biggestblock_l[23];
assign biggestblock[22] = biggestblock_l[22];
assign biggestblock[21] = biggestblock_l[21];
assign biggestblock[20] = biggestblock_l[20];
assign biggestblock[19] = biggestblock_l[19];
assign biggestblock[18] = biggestblock_l[18];
assign biggestblock[17] = biggestblock_l[17];
assign biggestblock[16] = biggestblock_l[16];
assign biggestblock[15] = biggestblock_l[15];
assign biggestblock[14] = biggestblock_l[14];
assign biggestblock[13] = biggestblock_l[13];
assign biggestblock[12] = biggestblock_l[12];
assign biggestblock[11] = biggestblock_l[11];
assign biggestblock[10] = biggestblock_l[10];
assign biggestblock[9] = biggestblock_l[9];
assign biggestblock[8] = biggestblock_l[8];
assign biggestblock[7] = biggestblock_l[7];
assign biggestblock[6] = biggestblock_l[6];
assign biggestblock[5] = biggestblock_l[5];
assign biggestblock[4] = biggestblock_l[4];
assign biggestblock[3] = biggestblock_l[3];
assign biggestblock[2] = biggestblock_l[2];
assign biggestblock[1] = biggestblock_l[1];
assign biggestblock[0] = biggestblock_l[0];
assign m_dec_0_q_int[36-1:32] = m_dec_0_q_int_l[8];
assign m_dec_0_q_int[32-1:28] = m_dec_0_q_int_l[7];
assign m_dec_0_q_int[28-1:24] = m_dec_0_q_int_l[6];
assign m_dec_0_q_int[24-1:20] = m_dec_0_q_int_l[5];
assign m_dec_0_q_int[20-1:16] = m_dec_0_q_int_l[4];
assign m_dec_0_q_int[16-1:12] = m_dec_0_q_int_l[3];
assign m_dec_0_q_int[12-1:8] = m_dec_0_q_int_l[2];
assign m_dec_0_q_int[8-1:4] = m_dec_0_q_int_l[1];
assign m_dec_0_q_int[4-1:0] = m_dec_0_q_int_l[0];
assign uart_0_shiftreg_0_par_int[7] = uart_0_shiftreg_0_latches[0];
assign uart_0_shiftreg_0_par_int[6] = uart_0_shiftreg_0_latches[1];
assign uart_0_shiftreg_0_par_int[5] = uart_0_shiftreg_0_latches[2];
assign uart_0_shiftreg_0_par_int[4] = uart_0_shiftreg_0_latches[3];
assign uart_0_shiftreg_0_par_int[3] = uart_0_shiftreg_0_latches[4];
assign uart_0_shiftreg_0_par_int[2] = uart_0_shiftreg_0_latches[5];
assign uart_0_shiftreg_0_par_int[1] = uart_0_shiftreg_0_latches[6];
assign uart_0_shiftreg_0_par_int[0] = uart_0_shiftreg_0_latches[7];
assign pts_controller_0_amphenol_int[49] = pts_controller_0_amphenol_l[49];
assign pts_controller_0_amphenol_int[48] = pts_controller_0_amphenol_l[48];
assign pts_controller_0_amphenol_int[47] = pts_controller_0_amphenol_l[47];
assign pts_controller_0_amphenol_int[46] = pts_controller_0_amphenol_l[46];
assign pts_controller_0_amphenol_int[45] = pts_controller_0_amphenol_l[45];
assign pts_controller_0_amphenol_int[44] = pts_controller_0_amphenol_l[44];
assign pts_controller_0_amphenol_int[43] = pts_controller_0_amphenol_l[43];
assign pts_controller_0_amphenol_int[42] = pts_controller_0_amphenol_l[42];
assign pts_controller_0_amphenol_int[41] = pts_controller_0_amphenol_l[41];
assign pts_controller_0_amphenol_int[40] = pts_controller_0_amphenol_l[40];
assign pts_controller_0_amphenol_int[39] = pts_controller_0_amphenol_l[39];
assign pts_controller_0_amphenol_int[38] = pts_controller_0_amphenol_l[38];
assign pts_controller_0_amphenol_int[37] = pts_controller_0_amphenol_l[37];
assign pts_controller_0_amphenol_int[36] = pts_controller_0_amphenol_l[36];
assign pts_controller_0_amphenol_int[35] = pts_controller_0_amphenol_l[35];
assign pts_controller_0_amphenol_int[34] = pts_controller_0_amphenol_l[34];
assign pts_controller_0_amphenol_int[33] = pts_controller_0_amphenol_l[33];
assign pts_controller_0_amphenol_int[32] = pts_controller_0_amphenol_l[32];
assign pts_controller_0_amphenol_int[31] = pts_controller_0_amphenol_l[31];
assign pts_controller_0_amphenol_int[30] = pts_controller_0_amphenol_l[30];
assign pts_controller_0_amphenol_int[29] = pts_controller_0_amphenol_l[29];
assign pts_controller_0_amphenol_int[28] = pts_controller_0_amphenol_l[28];
assign pts_controller_0_amphenol_int[27] = pts_controller_0_amphenol_l[27];
assign pts_controller_0_amphenol_int[26] = pts_controller_0_amphenol_l[26];
assign pts_controller_0_amphenol_int[25] = pts_controller_0_amphenol_l[25];
assign pts_controller_0_amphenol_int[24] = pts_controller_0_amphenol_l[24];
assign pts_controller_0_amphenol_int[23] = pts_controller_0_amphenol_l[23];
assign pts_controller_0_amphenol_int[22] = pts_controller_0_amphenol_l[22];
assign pts_controller_0_amphenol_int[21] = pts_controller_0_amphenol_l[21];
assign pts_controller_0_amphenol_int[20] = pts_controller_0_amphenol_l[20];
assign pts_controller_0_amphenol_int[19] = pts_controller_0_amphenol_l[19];
assign pts_controller_0_amphenol_int[18] = pts_controller_0_amphenol_l[18];
assign pts_controller_0_amphenol_int[17] = pts_controller_0_amphenol_l[17];
assign pts_controller_0_amphenol_int[16] = pts_controller_0_amphenol_l[16];
assign pts_controller_0_amphenol_int[15] = pts_controller_0_amphenol_l[15];
assign pts_controller_0_amphenol_int[14] = pts_controller_0_amphenol_l[14];
assign pts_controller_0_amphenol_int[13] = pts_controller_0_amphenol_l[13];
assign pts_controller_0_amphenol_int[12] = pts_controller_0_amphenol_l[12];
assign pts_controller_0_amphenol_int[11] = pts_controller_0_amphenol_l[11];
assign pts_controller_0_amphenol_int[10] = pts_controller_0_amphenol_l[10];
assign pts_controller_0_amphenol_int[9] = pts_controller_0_amphenol_l[9];
assign pts_controller_0_amphenol_int[8] = pts_controller_0_amphenol_l[8];
assign pts_controller_0_amphenol_int[7] = pts_controller_0_amphenol_l[7];
assign pts_controller_0_amphenol_int[6] = pts_controller_0_amphenol_l[6];
assign pts_controller_0_amphenol_int[5] = pts_controller_0_amphenol_l[5];
assign pts_controller_0_amphenol_int[4] = pts_controller_0_amphenol_l[4];
assign pts_controller_0_amphenol_int[3] = pts_controller_0_amphenol_l[3];
assign pts_controller_0_amphenol_int[2] = pts_controller_0_amphenol_l[2];
assign pts_controller_0_amphenol_int[1] = pts_controller_0_amphenol_l[1];
assign pts_controller_0_amphenol_int[0] = pts_controller_0_amphenol_l[0];


always @(posedge clk, posedge trigger_reset) begin: WITH_UART_M_MANAGER_0_LATCHER
    if (trigger_reset == 1) begin
        m_manager_0_set_freq_latch <= 00000000;
        m_manager_0_set_step_f_latch <= 00000000;
        m_manager_0_set_step_t_latch <= 00000000;
        m_manager_0_set_wait_latch <= 00000000;
        m_manager_0_start_time <= 0;
    end
    else begin
        if ((ready && start)) begin
            m_manager_0_set_freq_latch <= set_freq;
            m_manager_0_set_step_f_latch <= freq_step;
            m_manager_0_set_step_t_latch <= time_step;
            m_manager_0_set_wait_latch <= hold_time;
            m_manager_0_start_time <= 1;
        end
    end
end

// Our beloved finite state machine! For controlling the frequency stepping of the PTS.
// It drives m_dec, which is a special counter that has both a binary output, and hexadecimal
// output (which is what the PTS needs. It steps through the frequency schedule.
always @(posedge clk, posedge trigger_reset) begin: WITH_UART_M_MANAGER_0_FSM
    if (trigger_reset == 1) begin
        add <= 0;
        sub <= 0;
        m_manager_0_frequency_controller_en <= 0;
        m_manager_0_waiter_en <= 0;
        ready <= 1;
        m_manager_0_state <= 2'b00;
    end
    else begin
        if ((m_manager_0_state == 2'b00)) begin
            add <= 0;
            sub <= 0;
            m_manager_0_frequency_controller_en <= 1'b0;
            m_manager_0_waiter_en <= 1'b0;
            ready <= 1'b1;
            if ((start == 1'b1)) begin
                m_manager_0_state <= 2'b01;
            end
        end
        else if (((m_manager_0_state == 2'b01) && (!m_manager_0_quit_turnedon))) begin
            add <= m_manager_0_add_o_int;
            sub <= m_manager_0_sub_o_int;
            m_manager_0_frequency_controller_en <= 1'b1;
            m_manager_0_waiter_en <= 1'b0;
            ready <= 1'b0;
        end
        else if (((m_manager_0_state == 2'b01) && m_manager_0_quit_turnedon)) begin
            m_manager_0_state <= 2'b11;
        end
        else begin
            if (m_manager_0_start_holding_turnedon) begin
                m_manager_0_state <= 2'b00;
            end
            add <= 0;
            sub <= 0;
            m_manager_0_frequency_controller_en <= 1'b0;
            m_manager_0_waiter_en <= 1'b1;
            ready <= 1'b0;
        end
    end
end


always @(posedge m_manager_0_freq_controller_clk, posedge trigger_reset) begin: WITH_UART_M_MANAGER_0_FREQUENCY_CONTROLLER
    integer power;
    if (trigger_reset == 1) begin
        m_manager_0_delta_freq <= 00000000;
        m_manager_0_quit <= 0;
        m_manager_0_set_step_f_latch_int <= 00000000;
        m_manager_0_direction <= 1'b0;
        m_manager_0_set_freq_latch_int <= 00000000;
        m_manager_0_dec_clk_en <= 0;
        incr <= 000;
        m_manager_0_add_o_int <= 0;
        m_manager_0_sub_o_int <= 0;
    end
    else begin
        for (power=0; power<9; power=power+1) begin
            if (($signed({1'b0, m_manager_0_set_step_f_latch}) == power)) begin
                m_manager_0_delta_freq <= (10 ** power);
            end
        end
        if ((m_manager_0_curr_freq > m_manager_0_set_freq_latch)) begin
            m_manager_0_quit <= 0;
            if ((m_manager_0_direction == 1'b0)) begin
                if ((($signed({1'b0, m_manager_0_set_step_f_latch}) + m_manager_0_set_step_f_latch_int) >= 1)) begin
                    m_manager_0_set_step_f_latch_int <= (m_manager_0_set_step_f_latch_int - 1);
                end
                m_manager_0_direction <= 1'b1;
            end
            else begin
                m_manager_0_direction <= 1'b1;
            end
        end
        else if ((m_manager_0_curr_freq < (m_manager_0_set_freq_latch + m_manager_0_set_freq_latch_int))) begin
            m_manager_0_quit <= 0;
            if ((m_manager_0_direction == 1'b1)) begin
                if ((($signed({1'b0, m_manager_0_set_step_f_latch}) + m_manager_0_set_freq_latch_int) >= 1)) begin
                    m_manager_0_set_freq_latch_int <= (m_manager_0_set_freq_latch_int - 1);
                end
                m_manager_0_direction <= 1'b0;
            end
            else begin
                m_manager_0_direction <= 1'b0;
            end
        end
        else begin
            m_manager_0_dec_clk_en <= 0;
            incr <= 0;
            m_manager_0_add_o_int <= 0;
            m_manager_0_sub_o_int <= 0;
            m_manager_0_quit <= 1;
        end
        if ((m_manager_0_direction == 1'b0)) begin
            m_manager_0_add_o_int <= 1;
            m_manager_0_sub_o_int <= 0;
            incr <= ($signed({1'b0, m_manager_0_set_step_f_latch}) + m_manager_0_set_freq_latch_int);
            m_manager_0_dec_clk_en <= 1;
        end
        else begin
            m_manager_0_add_o_int <= 0;
            m_manager_0_sub_o_int <= 1;
            incr <= ($signed({1'b0, m_manager_0_set_step_f_latch}) + m_manager_0_set_freq_latch_int);
            m_manager_0_dec_clk_en <= 1;
        end
    end
end


always @(posedge m_manager_0_waiter_clk, posedge trigger_reset) begin: WITH_UART_M_MANAGER_0_HOLDER
    if (trigger_reset == 1) begin
        m_manager_0_start_holding <= 0;
        m_manager_0_set_wait_latch_int <= 00000000;
    end
    else begin
        if ((($signed({1'b0, m_manager_0_set_wait_latch}) + m_manager_0_set_wait_latch_int) == 0)) begin
            m_manager_0_start_holding <= 1;
        end
        else begin
            m_manager_0_start_holding <= 0;
            m_manager_0_set_wait_latch_int <= (m_manager_0_set_wait_latch_int - 1);
        end
    end
end



assign m_manager_0_freq_controller_clk = (m_manager_0_frequency_controller_en && m_manager_0_t_step_clk);
assign dec_clk = (m_manager_0_dec_clk_en && m_manager_0_t_step_clk);
assign m_manager_0_waiter_clk = (m_manager_0_waiter_en && clk);
assign m_manager_0_curr_freq = curr_freq;


always @(posedge clk, posedge trigger_reset) begin: WITH_UART_M_MANAGER_0_QUIT_MONITOR
    if (trigger_reset == 1) begin
        m_manager_0_quitold <= 0;
        m_manager_0_start_holdingold <= 0;
        m_manager_0_quit_turnedon <= 0;
        m_manager_0_start_holding_turnedon <= 0;
    end
    else begin
        m_manager_0_quitold <= m_manager_0_quit;
        m_manager_0_start_holdingold <= m_manager_0_start_holding;
        if (((m_manager_0_quitold == 0) && (m_manager_0_quit == 1))) begin
            m_manager_0_quit_turnedon <= 1;
        end
        else begin
            m_manager_0_quit_turnedon <= 0;
        end
        if (((m_manager_0_start_holdingold == 0) && (m_manager_0_start_holding == 1))) begin
            m_manager_0_start_holding_turnedon <= 1;
        end
        else begin
            m_manager_0_start_holding_turnedon <= 0;
        end
    end
end


always @(posedge m_manager_0_start_time, posedge trigger_reset) begin: WITH_UART_M_MANAGER_0_DEFINE_T_STEP_CLK
    if (trigger_reset == 1) begin
        m_manager_0_half_period <= 00000000;
    end
    else begin
        if ((m_manager_0_set_step_t_latch == 0)) begin
            m_manager_0_half_period <= 0;
        end
        else begin
            m_manager_0_half_period <= (m_manager_0_set_step_t_latch / 2);
        end
    end
end


always @(posedge clk, posedge trigger_reset) begin: WITH_UART_M_MANAGER_0_T_STEP_CLK_DRIVER
    if (trigger_reset == 1) begin
        m_manager_0_t_step_counter <= 00000000;
        m_manager_0_t_step_clk <= 0;
    end
    else begin
        if ((m_manager_0_t_step_counter < m_manager_0_half_period)) begin
            m_manager_0_t_step_counter <= (m_manager_0_t_step_counter + 1);
        end
        else begin
            m_manager_0_t_step_clk <= (!m_manager_0_t_step_clk);
            m_manager_0_t_step_counter <= 0;
        end
    end
end


always @(posedge dec_clk) begin: WITH_UART_M_DEC_0_WIRING
    hex_freq <= m_dec_0_q_int;
    curr_freq <= m_dec_0_bq_int;
end

// This is the HEXADECIMAL counter.
// It adds or subtracts only if (add xor sub) is True, to allow for the carry logic
// a new bit of logic is required, namely addlogic, and sublogic. They give out 
// lists of vectors (or integer masks). These are used in the logic below. And work 
// out most of the stuff. One extra if statement is needed to increment the desired 
// byte.
always @(negedge dec_clk, posedge reset) begin: WITH_UART_M_DEC_0_HEX_COUNTER
    integer digit;
    if (reset == 1) begin
        m_dec_0_q_int_l[0] <= 0;
        m_dec_0_q_int_l[1] <= 0;
        m_dec_0_q_int_l[2] <= 0;
        m_dec_0_q_int_l[3] <= 0;
        m_dec_0_q_int_l[4] <= 0;
        m_dec_0_q_int_l[5] <= 0;
        m_dec_0_q_int_l[6] <= 0;
        m_dec_0_q_int_l[7] <= 0;
        m_dec_0_q_int_l[8] <= 0;
    end
    else begin
        if (((add == 1'b1) && (!sub))) begin
            for (digit=1; digit<9; digit=digit+1) begin
                if ((digit > $signed({1'b0, incr}))) begin
                    if (m_dec_0_to_add[digit]) begin
                        if ((m_dec_0_q_int_l[digit] != 9)) begin
                            m_dec_0_q_int_l[digit] <= (m_dec_0_q_int_l[digit] + 1);
                        end
                        else begin
                            m_dec_0_q_int_l[digit] <= 0;
                        end
                    end
                    else begin
                        m_dec_0_q_int_l[digit] <= m_dec_0_q_int_l[digit];
                    end
                end
                else if ((digit == $signed({1'b0, incr}))) begin
                    if ((m_dec_0_q_int_l[incr] != 9)) begin
                        m_dec_0_q_int_l[incr] <= (m_dec_0_q_int_l[incr] + 1);
                    end
                    else begin
                        m_dec_0_q_int_l[incr] <= 0;
                    end
                end
            end
        end
        else if (((sub == 1'b1) && (!add))) begin
            for (digit=1; digit<9; digit=digit+1) begin
                if ((digit > $signed({1'b0, incr}))) begin
                    if (m_dec_0_to_subtract[digit]) begin
                        if ((m_dec_0_q_int_l[digit] != 0)) begin
                            m_dec_0_q_int_l[digit] <= (m_dec_0_q_int_l[digit] - 1);
                        end
                        else begin
                            m_dec_0_q_int_l[digit] <= 9;
                        end
                    end
                    else begin
                        m_dec_0_q_int_l[digit] <= m_dec_0_q_int_l[digit];
                    end
                end
                else if ((digit == $signed({1'b0, incr}))) begin
                    if ((m_dec_0_q_int_l[incr] != 0)) begin
                        m_dec_0_q_int_l[incr] <= (m_dec_0_q_int_l[incr] - 1);
                    end
                    else begin
                        m_dec_0_q_int_l[incr] <= 9;
                    end
                end
            end
        end
        else begin
            for (digit=0; digit<9; digit=digit+1) begin
                m_dec_0_q_int_l[digit] <= m_dec_0_q_int_l[digit];
            end
        end
    end
end

// This module determines whether or not to add certain bits,
// in the case of carry over. First we make sure we don't add all
// the bits lower than increment, then we set the increment bit to add,
// and lastly we perform the logic neccessary to determine if bits greater
// than incr need to be added
// 
// It's sensitivity list is long, this is neccessary as to allow the logic 
// to update to_add when any part of to_add changes, as is the case
// when performing carry logic.
always @(incr, m_dec_0_q_int, m_dec_0_to_add[0], m_dec_0_to_add[1], m_dec_0_to_add[2], m_dec_0_to_add[3], m_dec_0_to_add[4], m_dec_0_to_add[5], m_dec_0_to_add[6], m_dec_0_to_add[7], m_dec_0_to_add[8]) begin: WITH_UART_M_DEC_0_ADDLOGIC
    integer digit;
    for (digit=0; digit<9; digit=digit+1) begin
        if ((digit < $signed({1'b0, incr}))) begin
            m_dec_0_to_add[digit] <= 0;
        end
        else if ((digit == $signed({1'b0, incr}))) begin
            m_dec_0_to_add[incr] <= 1;
        end
        else begin
            m_dec_0_to_add[digit] <= ((m_dec_0_q_int_l[(digit - 1)] == 9) && m_dec_0_to_add[(digit - 1)]);
        end
    end
end

// This module determines whether or not to subtract certain bits,
// in the case of carry over. First we make sure we don't subtract all
// the bits lower than increment, then we set the increment bit to subtract,
// and lastly we perform the logic neccessary to determine if bits greater
// than incr need to be subtracted.
// 
// It's sensitivity list is long, this is neccessary as to allow the logic 
// to update to_subtract when any part of to_subtract changes, as is the case
// when performing carry logic.
always @(incr, m_dec_0_q_int, m_dec_0_to_subtract[0], m_dec_0_to_subtract[1], m_dec_0_to_subtract[2], m_dec_0_to_subtract[3], m_dec_0_to_subtract[4], m_dec_0_to_subtract[5], m_dec_0_to_subtract[6], m_dec_0_to_subtract[7], m_dec_0_to_subtract[8]) begin: WITH_UART_M_DEC_0_SUBLOGIC
    integer digit;
    for (digit=0; digit<9; digit=digit+1) begin
        if ((digit < $signed({1'b0, incr}))) begin
            m_dec_0_to_subtract[digit] <= 0;
        end
        else if ((digit == $signed({1'b0, incr}))) begin
            m_dec_0_to_subtract[incr] <= 1;
        end
        else begin
            m_dec_0_to_subtract[digit] <= ((m_dec_0_q_int_l[(digit - 1)] == 0) && m_dec_0_to_subtract[(digit - 1)]);
        end
    end
end

// Here is the binary counter for bq. 
// It's value should synchronously be the same
// as q. This logic should be simple, and it is,
// but it freaks out when you subtract too far. Be warned!
always @(negedge dec_clk, posedge reset) begin: WITH_UART_M_DEC_0_BIN_COUNTER
    if (reset == 1) begin
        m_dec_0_bq_int <= 00000000;
    end
    else begin
        if ((add && (!sub))) begin
            m_dec_0_bq_int <= (m_dec_0_bq_int + $signed({1'b0, m_dec_0_increment}));
        end
        else if ((sub && (!add))) begin
            m_dec_0_bq_int <= (m_dec_0_bq_int - $signed({1'b0, m_dec_0_increment}));
        end
        else begin
            m_dec_0_bq_int <= m_dec_0_bq_int;
        end
    end
end


always @(incr) begin: WITH_UART_M_DEC_0_ROM_0_READ
    case (incr)
        0: m_dec_0_increment = 1;
        1: m_dec_0_increment = 10;
        2: m_dec_0_increment = 100;
        3: m_dec_0_increment = 1000;
        4: m_dec_0_increment = 10000;
        5: m_dec_0_increment = 100000;
        6: m_dec_0_increment = 1000000;
        7: m_dec_0_increment = 10000000;
        default: m_dec_0_increment = 100000000;
    endcase
end


always @(posedge uart_0_baud, posedge reset) begin: WITH_UART_UART_0_CHECKFORENDBITS
    if (reset == 1) begin
        uart_0_bauds_held_down <= 0;
        uart_0_started <= 0;
    end
    else begin
        if ((!uart_0_started)) begin
            if ((fpga_rx == 0)) begin
                if ((uart_0_bauds_held_down != 4)) begin
                    uart_0_bauds_held_down <= (uart_0_bauds_held_down + 1);
                    uart_0_latch_en <= 0;
                end
                else begin
                    uart_0_bauds_held_down <= 0;
                    uart_0_started <= 1;
                    uart_0_latch_en <= 1;
                end
            end
            else begin
                uart_0_latch_en <= 0;
                uart_0_bauds_held_down <= 0;
            end
        end
        else begin
            if ((uart_0_bits_received == 8)) begin
                uart_0_latch_en <= 0;
            end
            else begin
                uart_0_latch_en <= 1;
            end
            if (((fpga_rx == 1) && (uart_0_bits_received == 8))) begin
                if (($signed({1'b0, uart_0_bauds_held_down}) != (4 + ((1 - 1) * 8)))) begin
                    uart_0_bauds_held_down <= (uart_0_bauds_held_down + 1);
                end
                else begin
                    uart_0_bauds_held_down <= 0;
                    uart_0_started <= 0;
                end
            end
            else if ((uart_0_bits_received == 8)) begin
                uart_0_bauds_held_down <= 0;
            end
        end
    end
end



assign uart_0_slowbaud_rst = (!uart_0_started);
assign uart_0_drdy_int = (!uart_0_started);


always @(posedge uart_0_slowbaud, posedge uart_0_slowbaud_rst) begin: WITH_UART_UART_0_COUNTTHEMBITS
    if (uart_0_slowbaud_rst == 1) begin
        uart_0_bits_received <= 00;
    end
    else begin
        if (uart_0_latch_en) begin
            uart_0_bits_received <= (uart_0_bits_received + 1);
        end
    end
end


always @(posedge clk, posedge reset) begin: WITH_UART_UART_0_DELAY_DRDY
    if (reset == 1) begin
        uart_0_drdy1 <= 1;
        uart_0_drdy2 <= 1;
    end
    else begin
        uart_0_drdy1 <= uart_0_drdy_int;
        uart_0_drdy2 <= uart_0_drdy1;
    end
end


always @(posedge uart_0_drdy_int, posedge reset) begin: WITH_UART_UART_0_LATCH_ON_READY
    if (reset == 1) begin
        rx_data <= 00;
    end
    else begin
        rx_data <= uart_0_rx_data_int;
    end
end


always @(posedge clk) begin: WITH_UART_UART_0_CLKDIV_0_CLOCKDIVIDER
    if ((($signed({1'b0, uart_0_clkdiv_0_counter}) == (156 - 1)) || (uart_0_clkdiv_0_counter == (156 / 2)))) begin
        uart_0_clkdiv_0_clk_new <= (!uart_0_clkdiv_0_clk_new);
    end
    if (($signed({1'b0, uart_0_clkdiv_0_counter}) == (156 - 1))) begin
        uart_0_clkdiv_0_counter <= 0;
    end
    else begin
        uart_0_clkdiv_0_counter <= (uart_0_clkdiv_0_counter + 1);
    end
end



assign uart_0_baud = uart_0_clkdiv_0_clk_new;


always @(posedge uart_0_baud, posedge uart_0_slowbaud_rst) begin: WITH_UART_UART_0_CLKDIV_1_CLOCKDIVIDER
    if (uart_0_slowbaud_rst == 1) begin
        uart_0_clkdiv_1_clk_new <= 0;
        uart_0_clkdiv_1_counter <= 0;
    end
    else begin
        if ((($signed({1'b0, uart_0_clkdiv_1_counter}) == (8 - 1)) || (uart_0_clkdiv_1_counter == (8 / 2)))) begin
            uart_0_clkdiv_1_clk_new <= (!uart_0_clkdiv_1_clk_new);
        end
        if (($signed({1'b0, uart_0_clkdiv_1_counter}) == (8 - 1))) begin
            uart_0_clkdiv_1_counter <= 0;
        end
        else begin
            uart_0_clkdiv_1_counter <= (uart_0_clkdiv_1_counter + 1);
        end
    end
end



assign uart_0_slowbaud = uart_0_clkdiv_1_clk_new;


always @(uart_0_slowbaud, uart_0_latch_en) begin: WITH_UART_UART_0_SHIFTREG_0_WIRING
    integer i;
    for (i=0; i<8; i=i+1) begin
        uart_0_shiftreg_0_clk_int <= (uart_0_slowbaud && uart_0_latch_en);
    end
end


always @(posedge uart_0_shiftreg_0_clk_int) begin: WITH_UART_UART_0_SHIFTREG_0_LATCHER
    integer i;
    reg [0-1:0] loadval;
    if ((1'b0 == 1'b0)) begin
        uart_0_shiftreg_0_latches[0] <= fpga_rx;
        for (i=1; i<8; i=i+1) begin
            uart_0_shiftreg_0_latches[i] <= uart_0_shiftreg_0_latches[(i - 1)];
        end
    end
    else begin
        for (i=0; i<8; i=i+1) begin
            uart_0_shiftreg_0_latches[i] <= loadval[i];
        end
    end
end



assign uart_0_rx_data_int = uart_0_shiftreg_0_par_int;



assign drdy = ((uart_0_drdy1 ^ uart_0_drdy2) & uart_0_drdy1);


always @(posedge freq_rambus_clk) begin: WITH_UART_BUSSEDRAM_0_WRITE
    if (bussedram_0_rambus_we) begin
        bussedram_0_mem[freq_rambus_waddr] <= freq_rambus_din;
    end
end



assign freq_rambus_dout = bussedram_0_mem[freq_rambus_raddr];


always @(posedge fstep_rambus_clk) begin: WITH_UART_BUSSEDRAM_1_WRITE
    if (bussedram_1_rambus_we) begin
        bussedram_1_mem[fstep_rambus_waddr] <= fstep_rambus_din;
    end
end



assign fstep_rambus_dout = bussedram_1_mem[fstep_rambus_raddr];


always @(posedge tstep_rambus_clk) begin: WITH_UART_BUSSEDRAM_2_WRITE
    if (bussedram_2_rambus_we) begin
        bussedram_2_mem[tstep_rambus_waddr] <= tstep_rambus_din;
    end
end



assign tstep_rambus_dout = bussedram_2_mem[tstep_rambus_raddr];


always @(posedge hold_rambus_clk) begin: WITH_UART_BUSSEDRAM_3_WRITE
    if (bussedram_3_rambus_we) begin
        bussedram_3_mem[hold_rambus_waddr] <= hold_rambus_din;
    end
end



assign hold_rambus_dout = bussedram_3_mem[hold_rambus_raddr];


always @(posedge ready, posedge trigger_reset) begin: WITH_UART_SCHEDULE_ARBITER
    if (trigger_reset == 1) begin
        start <= 0;
        sched_index <= 00;
    end
    else begin
        if ((all_data_received && (!done))) begin
            start <= 1;
            sched_index <= (sched_index + 1);
        end
        else begin
            start <= 0;
        end
    end
end

// This fsm latches (just after) the dataready positive edge
// signal. The data is guaranteed to be ready then.
always @(posedge clk) begin: WITH_UART_COMMS_ARBITER_0_FSM
    integer i;
    if (comms_arbiter_0_delayed_reset2 == 1) begin
        bussedram_0_rambus_we <= 0;
        bussedram_1_rambus_we <= 0;
        bussedram_2_rambus_we <= 0;
        bussedram_3_rambus_we <= 0;
        whichram <= 00;
        state <= 2'b00;
        comms_arbiter_0_latch_counter <= 00;
        biggestblock_l[0] <= 0;
        biggestblock_l[1] <= 0;
        biggestblock_l[2] <= 0;
        biggestblock_l[3] <= 0;
        biggestblock_l[4] <= 0;
        biggestblock_l[5] <= 0;
        biggestblock_l[6] <= 0;
        biggestblock_l[7] <= 0;
        biggestblock_l[8] <= 0;
        biggestblock_l[9] <= 0;
        biggestblock_l[10] <= 0;
        biggestblock_l[11] <= 0;
        biggestblock_l[12] <= 0;
        biggestblock_l[13] <= 0;
        biggestblock_l[14] <= 0;
        biggestblock_l[15] <= 0;
        biggestblock_l[16] <= 0;
        biggestblock_l[17] <= 0;
        biggestblock_l[18] <= 0;
        biggestblock_l[19] <= 0;
        biggestblock_l[20] <= 0;
        biggestblock_l[21] <= 0;
        biggestblock_l[22] <= 0;
        biggestblock_l[23] <= 0;
        biggestblock_l[24] <= 0;
        biggestblock_l[25] <= 0;
        biggestblock_l[26] <= 0;
        biggestblock_l[27] <= 0;
        biggestblock_l[28] <= 0;
        biggestblock_l[29] <= 0;
        biggestblock_l[30] <= 0;
        biggestblock_l[31] <= 0;
        freq_rambus_length <= 00;
        freq_rambus_addr <= 00;
        all_data_received <= 0;
        fstep_rambus_length <= 00;
        fstep_rambus_addr <= 00;
        tstep_rambus_length <= 00;
        tstep_rambus_addr <= 00;
        hold_rambus_length <= 00;
        hold_rambus_addr <= 00;
    end
    else begin
        if (((state == 2'b00) && comms_arbiter_0_drdy_turnedon)) begin
            bussedram_0_rambus_we <= 0;
            bussedram_1_rambus_we <= 0;
            bussedram_2_rambus_we <= 0;
            bussedram_3_rambus_we <= 0;
            whichram <= rx_data;
            state <= 2'b01;
        end
        else if (((state == 2'b01) && comms_arbiter_0_drdy_turnedon)) begin
            comms_arbiter_0_latch_counter <= (comms_arbiter_0_latch_counter + 1);
            for (i=0; i<8; i=i+1) begin
                biggestblock_l[(i + (8 * comms_arbiter_0_latch_counter))] <= rx_data[i];
            end
            if ((comms_arbiter_0_latch_counter == 3)) begin
                comms_arbiter_0_latch_counter <= 0;
                state <= 2'b10;
            end
        end
        else if ((state == 2'b10)) begin
            case (whichram)
                'h0: begin
                    bussedram_0_rambus_we <= 1;
                    freq_rambus_length <= (freq_rambus_length + 1);
                    freq_rambus_addr <= (freq_rambus_addr + 1);
                    all_data_received <= 0;
                end
                'h1: begin
                    bussedram_1_rambus_we <= 1;
                    fstep_rambus_length <= (fstep_rambus_length + 1);
                    fstep_rambus_addr <= (fstep_rambus_addr + 1);
                    all_data_received <= 0;
                end
                'h2: begin
                    bussedram_2_rambus_we <= 1;
                    tstep_rambus_length <= (tstep_rambus_length + 1);
                    tstep_rambus_addr <= (tstep_rambus_addr + 1);
                    all_data_received <= 0;
                end
                'h3: begin
                    bussedram_3_rambus_we <= 1;
                    hold_rambus_length <= (hold_rambus_length + 1);
                    hold_rambus_addr <= (hold_rambus_addr + 1);
                    all_data_received <= 0;
                end
                'h16: begin
                    bussedram_0_rambus_we <= 0;
                    bussedram_1_rambus_we <= 0;
                    bussedram_2_rambus_we <= 0;
                    bussedram_3_rambus_we <= 0;
                    all_data_received <= 1;
                end
                default: begin
                    bussedram_0_rambus_we <= 0;
                    bussedram_1_rambus_we <= 0;
                    bussedram_2_rambus_we <= 0;
                    bussedram_3_rambus_we <= 0;
                end
            endcase
            state <= 2'b00;
        end
        else begin
            bussedram_0_rambus_we <= 0;
            bussedram_1_rambus_we <= 0;
            bussedram_2_rambus_we <= 0;
            bussedram_3_rambus_we <= 0;
        end
    end
end

// This is a little block for determining whether 
// drdy has transitioned in the last clock cycle.
// It effectively turns the drdy step function into 
// a hat function.
always @(posedge clk, posedge reset) begin: WITH_UART_COMMS_ARBITER_0_DRDY_MONITOR
    if (reset == 1) begin
        comms_arbiter_0_drdy_old <= 1;
        comms_arbiter_0_drdy_turnedon <= 0;
    end
    else begin
        comms_arbiter_0_drdy_old <= drdy;
        if (((drdy != comms_arbiter_0_drdy_old) && (comms_arbiter_0_drdy_old == 0))) begin
            comms_arbiter_0_drdy_turnedon <= 1;
        end
        else begin
            comms_arbiter_0_drdy_turnedon <= 0;
        end
    end
end


always @(posedge clk) begin: WITH_UART_COMMS_ARBITER_0_RESET_DELAYER
    comms_arbiter_0_delayed_reset1 <= reset;
    comms_arbiter_0_delayed_reset2 <= comms_arbiter_0_delayed_reset1;
end

// Just connect the notclock signal for passing into the RAMs  

assign notclock = (!clk);

// Combinatorial logic here to determine
// the schedule length as the smallest amount of data points stuck into the RAMs
always @(freq_rambus_length, fstep_rambus_length, tstep_rambus_length, hold_rambus_length) begin: WITH_UART_DETERMINE_SCHED_LEN
    if (((freq_rambus_length < fstep_rambus_length) && (freq_rambus_length < tstep_rambus_length) && (freq_rambus_length < hold_rambus_length))) begin
        sched_len = freq_rambus_length;
    end
    else if (((tstep_rambus_length < fstep_rambus_length) && (tstep_rambus_length < freq_rambus_length) && (tstep_rambus_length < hold_rambus_length))) begin
        sched_len = tstep_rambus_length;
    end
    else if (((hold_rambus_length < fstep_rambus_length) && (hold_rambus_length < freq_rambus_length) && (hold_rambus_length < tstep_rambus_length))) begin
        sched_len = hold_rambus_length;
    end
    else begin
        sched_len = fstep_rambus_length;
    end
end

// Connect basic signals of the RAMS: data in and data_out and clock

assign freq_rambus_din = biggestblock[32-1:0];
assign fstep_rambus_din = biggestblock[32-1:0];
assign tstep_rambus_din = biggestblock[32-1:0];
assign hold_rambus_din = biggestblock[32-1:0];
assign set_freq = freq_rambus_dout;
assign freq_step = fstep_rambus_dout;
assign time_step = tstep_rambus_dout;
assign hold_time = hold_rambus_dout;
assign freq_rambus_clk = notclock;
assign fstep_rambus_clk = notclock;
assign tstep_rambus_clk = notclock;
assign hold_rambus_clk = notclock;
assign freq_rambus_raddr = sched_index;
assign fstep_rambus_raddr = sched_index;
assign tstep_rambus_raddr = sched_index;
assign hold_rambus_raddr = sched_index;
assign freq_rambus_waddr = freq_rambus_addr;
assign fstep_rambus_waddr = fstep_rambus_addr;
assign tstep_rambus_waddr = tstep_rambus_addr;
assign hold_rambus_waddr = hold_rambus_addr;


always @(sched_len, sched_index, all_data_received) begin: WITH_UART_WHEN_DONE
    if (((sched_len == sched_index) && all_data_received)) begin
        done = 1;
    end
    else begin
        done = 0;
    end
end



assign trigger_reset = (trigger && all_data_received);


always @(all_data_received, whichram) begin: WITH_UART_LED_WIRING
    integer i;
    led2[8] = all_data_received;
    for (i=0; i<8; i=i+1) begin
        led2[i] = whichram[i];
    end
end



assign amphenol = pts_controller_0_amphenol_int;
assign pts_controller_0_amphenol_l[49] = 0;
assign pts_controller_0_amphenol_l[48] = 1;
assign pts_controller_0_amphenol_l[41] = (!pts_controller_0_pts_enable);
assign pts_controller_0_amphenol_l[20] = 0;
assign pts_controller_0_amphenol_l[21] = 0;
assign pts_controller_0_amphenol_l[22] = 1;
assign pts_controller_0_amphenol_l[23] = 1;
assign pts_controller_0_amphenol_l[24] = 1;
assign pts_controller_0_amphenol_l[45] = 1;
assign pts_controller_0_amphenol_l[46] = 1;
assign pts_controller_0_amphenol_l[43] = (!hex_freq[33]);
assign pts_controller_0_amphenol_l[42] = (!hex_freq[32]);
assign pts_controller_0_amphenol_l[40] = (!hex_freq[31]);
assign pts_controller_0_amphenol_l[39] = (!hex_freq[30]);
assign pts_controller_0_amphenol_l[15] = (!hex_freq[29]);
assign pts_controller_0_amphenol_l[14] = (!hex_freq[28]);
assign pts_controller_0_amphenol_l[19] = (!hex_freq[27]);
assign pts_controller_0_amphenol_l[18] = (!hex_freq[26]);
assign pts_controller_0_amphenol_l[17] = (!hex_freq[25]);
assign pts_controller_0_amphenol_l[16] = (!hex_freq[24]);
assign pts_controller_0_amphenol_l[26] = (!hex_freq[23]);
assign pts_controller_0_amphenol_l[25] = (!hex_freq[22]);
assign pts_controller_0_amphenol_l[1] = (!hex_freq[21]);
assign pts_controller_0_amphenol_l[0] = (!hex_freq[20]);
assign pts_controller_0_amphenol_l[28] = (!hex_freq[19]);
assign pts_controller_0_amphenol_l[27] = (!hex_freq[18]);
assign pts_controller_0_amphenol_l[3] = (!hex_freq[17]);
assign pts_controller_0_amphenol_l[2] = (!hex_freq[16]);
assign pts_controller_0_amphenol_l[30] = (!hex_freq[15]);
assign pts_controller_0_amphenol_l[29] = (!hex_freq[14]);
assign pts_controller_0_amphenol_l[5] = (!hex_freq[13]);
assign pts_controller_0_amphenol_l[4] = (!hex_freq[12]);
assign pts_controller_0_amphenol_l[32] = (!hex_freq[11]);
assign pts_controller_0_amphenol_l[31] = (!hex_freq[10]);
assign pts_controller_0_amphenol_l[7] = (!hex_freq[9]);
assign pts_controller_0_amphenol_l[6] = (!hex_freq[8]);
assign pts_controller_0_amphenol_l[34] = (!hex_freq[7]);
assign pts_controller_0_amphenol_l[33] = (!hex_freq[6]);
assign pts_controller_0_amphenol_l[9] = (!hex_freq[5]);
assign pts_controller_0_amphenol_l[8] = (!hex_freq[4]);
assign pts_controller_0_amphenol_l[36] = (!hex_freq[3]);
assign pts_controller_0_amphenol_l[35] = (!hex_freq[2]);
assign pts_controller_0_amphenol_l[11] = (!hex_freq[1]);
assign pts_controller_0_amphenol_l[10] = (!hex_freq[0]);
assign pts_controller_0_amphenol_l[38] = 0;
assign pts_controller_0_amphenol_l[37] = 1;
assign pts_controller_0_amphenol_l[13] = 1;
assign pts_controller_0_amphenol_l[12] = 1;

endmodule
