-- File: top.vhd
-- Generated by MyHDL 1.0dev
-- Date: Thu Jul 14 12:14:38 2016


library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use std.textio.all;

use work.pck_myhdl_10.all;

entity top is
    port (
        clk: in std_logic;
        trigger: in std_logic;
        fpga_rx: in std_logic;
        fpga_tx: in std_logic;
        amphenol: out unsigned(49 downto 0)
    );
end entity top;


architecture MyHDL of top is


type t_enum_d_state_2 is (
    UP,
    DOWN
);
type t_enum_t_state_1 is (
    WAIT,
    REACH_DESIRED,
    REACH_DESIRED_CHANGE_STEP,
    HOLD_FREQ
);
type t_enum_t_state_3 is (
    READWHICHRAM,
    PARSEFORRAM,
    SENDTORAM,
    RESET
);

signal hex_freq: unsigned(31 downto 0);
signal with_uart_1_curr_freq: unsigned(31 downto 0);
signal with_uart_1_add: std_logic;
signal with_uart_1_sub: std_logic;
signal with_uart_1_dec_clk: std_logic;
signal with_uart_1_incr: unsigned(8 downto 0);
signal with_uart_1_sched_len: unsigned(6 downto 0);
signal with_uart_1_set_freq: unsigned(31 downto 0);
signal with_uart_1_freq_step: unsigned(31 downto 0);
signal with_uart_1_time_step: unsigned(31 downto 0);
signal with_uart_1_hold_time: unsigned(31 downto 0);
signal with_uart_1_sched_index: unsigned(7 downto 0);
signal with_uart_1_reset: std_logic;
signal with_uart_1_notclock: std_logic;
signal with_uart_1_start: std_logic;
signal with_uart_1_ready: std_logic;
signal with_uart_1_done: std_logic;
signal with_uart_1_whichram: unsigned(7 downto 0);
signal with_uart_1_biggestblock: unsigned(31 downto 0);
signal with_uart_1_state: t_enum_t_state_3;
signal with_uart_1_rx_data: unsigned(7 downto 0);
signal with_uart_1_drdy: std_logic;
signal with_uart_1_freq_rambus_addr: unsigned(7 downto 0);
signal with_uart_1_fstep_rambus_addr: unsigned(7 downto 0);
signal with_uart_1_tstep_rambus_addr: unsigned(7 downto 0);
signal with_uart_1_hold_rambus_addr: unsigned(7 downto 0);
signal with_uart_1_freq_rambus_length: unsigned(7 downto 0);
signal with_uart_1_fstep_rambus_length: unsigned(7 downto 0);
signal with_uart_1_tstep_rambus_length: unsigned(7 downto 0);
signal with_uart_1_hold_rambus_length: unsigned(7 downto 0);
signal with_uart_1_freq_rambus_din: unsigned(31 downto 0);
signal with_uart_1_fstep_rambus_din: unsigned(31 downto 0);
signal with_uart_1_tstep_rambus_din: unsigned(31 downto 0);
signal with_uart_1_hold_rambus_din: unsigned(31 downto 0);
signal with_uart_1_freq_rambus_dout: unsigned(31 downto 0);
signal with_uart_1_fstep_rambus_dout: unsigned(31 downto 0);
signal with_uart_1_tstep_rambus_dout: unsigned(31 downto 0);
signal with_uart_1_hold_rambus_dout: unsigned(31 downto 0);
signal with_uart_1_freq_rambus_clk: std_logic;
signal with_uart_1_fstep_rambus_clk: std_logic;
signal with_uart_1_tstep_rambus_clk: std_logic;
signal with_uart_1_hold_rambus_clk: std_logic;
signal with_uart_1_freq_rambus_addr_renamed0: unsigned(6 downto 0);
signal with_uart_1_fstep_rambus_addr_renamed0: unsigned(6 downto 0);
signal with_uart_1_tstep_rambus_addr_renamed0: unsigned(6 downto 0);
signal with_uart_1_hold_rambus_addr_renamed0: unsigned(6 downto 0);
signal with_uart_1_m_manager_1_curr_freq: signed (30 downto 0);
signal with_uart_1_m_manager_1_set_freq_latch: signed (30 downto 0);
signal with_uart_1_m_manager_1_set_step_f_latch: unsigned(29 downto 0);
signal with_uart_1_m_manager_1_set_step_t_latch: unsigned(29 downto 0);
signal with_uart_1_m_manager_1_set_wait_latch: unsigned(29 downto 0);
signal with_uart_1_m_manager_1_set_freq_latch_int: signed (30 downto 0);
signal with_uart_1_m_manager_1_set_step_f_latch_int: signed (30 downto 0);
signal with_uart_1_m_manager_1_set_wait_latch_int: signed (30 downto 0);
signal with_uart_1_m_manager_1_frequency_controller_en: std_logic;
signal with_uart_1_m_manager_1_waiter_en: std_logic;
signal with_uart_1_m_manager_1_quit: std_logic;
signal with_uart_1_m_manager_1_start_holding: std_logic;
signal with_uart_1_m_manager_1_quit_turnedon: std_logic;
signal with_uart_1_m_manager_1_start_holding_turnedon: std_logic;
signal with_uart_1_m_manager_1_state: t_enum_t_state_1;
signal with_uart_1_m_manager_1_add_o_int: std_logic;
signal with_uart_1_m_manager_1_sub_o_int: std_logic;
signal with_uart_1_m_manager_1_dec_clk_int: std_logic;
signal with_uart_1_m_manager_1_delta_freq: unsigned(29 downto 0);
signal with_uart_1_m_manager_1_direction: t_enum_d_state_2;
signal with_uart_1_m_manager_1_dec_clk_en: std_logic;
signal with_uart_1_m_manager_1_freq_controller_clk: std_logic;
signal with_uart_1_m_manager_1_waiter_clk: std_logic;
signal with_uart_1_m_manager_1_quitold: std_logic;
signal with_uart_1_m_manager_1_start_holdingold: std_logic;
signal with_uart_1_m_dec_1_q_int: unsigned(35 downto 0);
signal with_uart_1_m_dec_1_bq_int: signed (30 downto 0);
signal with_uart_1_m_dec_1_increment: unsigned(29 downto 0);
signal with_uart_1_uart_1_baud: std_logic;
signal with_uart_1_uart_1_slowbaud: std_logic;
signal with_uart_1_uart_1_slowbaud_rst: std_logic;
signal with_uart_1_uart_1_started: std_logic;
signal with_uart_1_uart_1_bauds_held_down: unsigned(2 downto 0);
signal with_uart_1_uart_1_bits_received: unsigned(4 downto 0);
signal with_uart_1_uart_1_latch_en: std_logic;
signal with_uart_1_uart_1_clkdiv_2_clk_new: std_logic;
signal with_uart_1_uart_1_clkdiv_2_counter: unsigned(7 downto 0);
signal with_uart_1_uart_1_clkdiv_3_clk_new: std_logic;
signal with_uart_1_uart_1_clkdiv_3_counter: unsigned(2 downto 0);
signal with_uart_1_uart_1_shiftreg_1_par_int: unsigned(7 downto 0);
signal with_uart_1_uart_1_shiftreg_1_clk_int: std_logic;
signal with_uart_1_bussedram_4_rambus_we: std_logic;
signal with_uart_1_bussedram_5_rambus_we: std_logic;
signal with_uart_1_bussedram_6_rambus_we: std_logic;
signal with_uart_1_bussedram_7_rambus_we: std_logic;
signal with_uart_1_comms_arbiter_0_latch_counter: unsigned(7 downto 0);
signal with_uart_1_comms_arbiter_0_drdy_turnedon: std_logic;
signal with_uart_1_comms_arbiter_0_drdy_old: std_logic;
signal pts_controller_0_amphenol_int: unsigned(49 downto 0);
type t_array_with_uart_1_biggestblock_l is array(0 to 32-1) of std_logic;
signal with_uart_1_biggestblock_l: t_array_with_uart_1_biggestblock_l;
type t_array_with_uart_1_m_dec_1_to_subtract is array(0 to 9-1) of std_logic;
signal with_uart_1_m_dec_1_to_subtract: t_array_with_uart_1_m_dec_1_to_subtract;
type t_array_with_uart_1_m_dec_1_to_add is array(0 to 9-1) of std_logic;
signal with_uart_1_m_dec_1_to_add: t_array_with_uart_1_m_dec_1_to_add;
type t_array_with_uart_1_m_dec_1_q_int_l is array(0 to 9-1) of unsigned(3 downto 0);
signal with_uart_1_m_dec_1_q_int_l: t_array_with_uart_1_m_dec_1_q_int_l;
type t_array_with_uart_1_uart_1_shiftreg_1_latches is array(0 to 8-1) of std_logic;
signal with_uart_1_uart_1_shiftreg_1_latches: t_array_with_uart_1_uart_1_shiftreg_1_latches;
type t_array_with_uart_1_bussedram_4_mem is array(0 to 128-1) of unsigned(31 downto 0);
signal with_uart_1_bussedram_4_mem: t_array_with_uart_1_bussedram_4_mem;
type t_array_with_uart_1_bussedram_5_mem is array(0 to 128-1) of unsigned(31 downto 0);
signal with_uart_1_bussedram_5_mem: t_array_with_uart_1_bussedram_5_mem;
type t_array_with_uart_1_bussedram_6_mem is array(0 to 128-1) of unsigned(31 downto 0);
signal with_uart_1_bussedram_6_mem: t_array_with_uart_1_bussedram_6_mem;
type t_array_with_uart_1_bussedram_7_mem is array(0 to 128-1) of unsigned(31 downto 0);
signal with_uart_1_bussedram_7_mem: t_array_with_uart_1_bussedram_7_mem;
type t_array_pts_controller_0_amphenol_l is array(0 to 50-1) of std_logic;
signal pts_controller_0_amphenol_l: t_array_pts_controller_0_amphenol_l;

begin



with_uart_1_biggestblock(31) <= with_uart_1_biggestblock_l(31);
with_uart_1_biggestblock(30) <= with_uart_1_biggestblock_l(30);
with_uart_1_biggestblock(29) <= with_uart_1_biggestblock_l(29);
with_uart_1_biggestblock(28) <= with_uart_1_biggestblock_l(28);
with_uart_1_biggestblock(27) <= with_uart_1_biggestblock_l(27);
with_uart_1_biggestblock(26) <= with_uart_1_biggestblock_l(26);
with_uart_1_biggestblock(25) <= with_uart_1_biggestblock_l(25);
with_uart_1_biggestblock(24) <= with_uart_1_biggestblock_l(24);
with_uart_1_biggestblock(23) <= with_uart_1_biggestblock_l(23);
with_uart_1_biggestblock(22) <= with_uart_1_biggestblock_l(22);
with_uart_1_biggestblock(21) <= with_uart_1_biggestblock_l(21);
with_uart_1_biggestblock(20) <= with_uart_1_biggestblock_l(20);
with_uart_1_biggestblock(19) <= with_uart_1_biggestblock_l(19);
with_uart_1_biggestblock(18) <= with_uart_1_biggestblock_l(18);
with_uart_1_biggestblock(17) <= with_uart_1_biggestblock_l(17);
with_uart_1_biggestblock(16) <= with_uart_1_biggestblock_l(16);
with_uart_1_biggestblock(15) <= with_uart_1_biggestblock_l(15);
with_uart_1_biggestblock(14) <= with_uart_1_biggestblock_l(14);
with_uart_1_biggestblock(13) <= with_uart_1_biggestblock_l(13);
with_uart_1_biggestblock(12) <= with_uart_1_biggestblock_l(12);
with_uart_1_biggestblock(11) <= with_uart_1_biggestblock_l(11);
with_uart_1_biggestblock(10) <= with_uart_1_biggestblock_l(10);
with_uart_1_biggestblock(9) <= with_uart_1_biggestblock_l(9);
with_uart_1_biggestblock(8) <= with_uart_1_biggestblock_l(8);
with_uart_1_biggestblock(7) <= with_uart_1_biggestblock_l(7);
with_uart_1_biggestblock(6) <= with_uart_1_biggestblock_l(6);
with_uart_1_biggestblock(5) <= with_uart_1_biggestblock_l(5);
with_uart_1_biggestblock(4) <= with_uart_1_biggestblock_l(4);
with_uart_1_biggestblock(3) <= with_uart_1_biggestblock_l(3);
with_uart_1_biggestblock(2) <= with_uart_1_biggestblock_l(2);
with_uart_1_biggestblock(1) <= with_uart_1_biggestblock_l(1);
with_uart_1_biggestblock(0) <= with_uart_1_biggestblock_l(0);
with_uart_1_m_dec_1_q_int(36-1 downto 32) <= with_uart_1_m_dec_1_q_int_l(8);
with_uart_1_m_dec_1_q_int(32-1 downto 28) <= with_uart_1_m_dec_1_q_int_l(7);
with_uart_1_m_dec_1_q_int(28-1 downto 24) <= with_uart_1_m_dec_1_q_int_l(6);
with_uart_1_m_dec_1_q_int(24-1 downto 20) <= with_uart_1_m_dec_1_q_int_l(5);
with_uart_1_m_dec_1_q_int(20-1 downto 16) <= with_uart_1_m_dec_1_q_int_l(4);
with_uart_1_m_dec_1_q_int(16-1 downto 12) <= with_uart_1_m_dec_1_q_int_l(3);
with_uart_1_m_dec_1_q_int(12-1 downto 8) <= with_uart_1_m_dec_1_q_int_l(2);
with_uart_1_m_dec_1_q_int(8-1 downto 4) <= with_uart_1_m_dec_1_q_int_l(1);
with_uart_1_m_dec_1_q_int(4-1 downto 0) <= with_uart_1_m_dec_1_q_int_l(0);
with_uart_1_uart_1_shiftreg_1_par_int(7) <= with_uart_1_uart_1_shiftreg_1_latches(0);
with_uart_1_uart_1_shiftreg_1_par_int(6) <= with_uart_1_uart_1_shiftreg_1_latches(1);
with_uart_1_uart_1_shiftreg_1_par_int(5) <= with_uart_1_uart_1_shiftreg_1_latches(2);
with_uart_1_uart_1_shiftreg_1_par_int(4) <= with_uart_1_uart_1_shiftreg_1_latches(3);
with_uart_1_uart_1_shiftreg_1_par_int(3) <= with_uart_1_uart_1_shiftreg_1_latches(4);
with_uart_1_uart_1_shiftreg_1_par_int(2) <= with_uart_1_uart_1_shiftreg_1_latches(5);
with_uart_1_uart_1_shiftreg_1_par_int(1) <= with_uart_1_uart_1_shiftreg_1_latches(6);
with_uart_1_uart_1_shiftreg_1_par_int(0) <= with_uart_1_uart_1_shiftreg_1_latches(7);
pts_controller_0_amphenol_int(49) <= pts_controller_0_amphenol_l(49);
pts_controller_0_amphenol_int(48) <= pts_controller_0_amphenol_l(48);
pts_controller_0_amphenol_int(47) <= pts_controller_0_amphenol_l(47);
pts_controller_0_amphenol_int(46) <= pts_controller_0_amphenol_l(46);
pts_controller_0_amphenol_int(45) <= pts_controller_0_amphenol_l(45);
pts_controller_0_amphenol_int(44) <= pts_controller_0_amphenol_l(44);
pts_controller_0_amphenol_int(43) <= pts_controller_0_amphenol_l(43);
pts_controller_0_amphenol_int(42) <= pts_controller_0_amphenol_l(42);
pts_controller_0_amphenol_int(41) <= pts_controller_0_amphenol_l(41);
pts_controller_0_amphenol_int(40) <= pts_controller_0_amphenol_l(40);
pts_controller_0_amphenol_int(39) <= pts_controller_0_amphenol_l(39);
pts_controller_0_amphenol_int(38) <= pts_controller_0_amphenol_l(38);
pts_controller_0_amphenol_int(37) <= pts_controller_0_amphenol_l(37);
pts_controller_0_amphenol_int(36) <= pts_controller_0_amphenol_l(36);
pts_controller_0_amphenol_int(35) <= pts_controller_0_amphenol_l(35);
pts_controller_0_amphenol_int(34) <= pts_controller_0_amphenol_l(34);
pts_controller_0_amphenol_int(33) <= pts_controller_0_amphenol_l(33);
pts_controller_0_amphenol_int(32) <= pts_controller_0_amphenol_l(32);
pts_controller_0_amphenol_int(31) <= pts_controller_0_amphenol_l(31);
pts_controller_0_amphenol_int(30) <= pts_controller_0_amphenol_l(30);
pts_controller_0_amphenol_int(29) <= pts_controller_0_amphenol_l(29);
pts_controller_0_amphenol_int(28) <= pts_controller_0_amphenol_l(28);
pts_controller_0_amphenol_int(27) <= pts_controller_0_amphenol_l(27);
pts_controller_0_amphenol_int(26) <= pts_controller_0_amphenol_l(26);
pts_controller_0_amphenol_int(25) <= pts_controller_0_amphenol_l(25);
pts_controller_0_amphenol_int(24) <= pts_controller_0_amphenol_l(24);
pts_controller_0_amphenol_int(23) <= pts_controller_0_amphenol_l(23);
pts_controller_0_amphenol_int(22) <= pts_controller_0_amphenol_l(22);
pts_controller_0_amphenol_int(21) <= pts_controller_0_amphenol_l(21);
pts_controller_0_amphenol_int(20) <= pts_controller_0_amphenol_l(20);
pts_controller_0_amphenol_int(19) <= pts_controller_0_amphenol_l(19);
pts_controller_0_amphenol_int(18) <= pts_controller_0_amphenol_l(18);
pts_controller_0_amphenol_int(17) <= pts_controller_0_amphenol_l(17);
pts_controller_0_amphenol_int(16) <= pts_controller_0_amphenol_l(16);
pts_controller_0_amphenol_int(15) <= pts_controller_0_amphenol_l(15);
pts_controller_0_amphenol_int(14) <= pts_controller_0_amphenol_l(14);
pts_controller_0_amphenol_int(13) <= pts_controller_0_amphenol_l(13);
pts_controller_0_amphenol_int(12) <= pts_controller_0_amphenol_l(12);
pts_controller_0_amphenol_int(11) <= pts_controller_0_amphenol_l(11);
pts_controller_0_amphenol_int(10) <= pts_controller_0_amphenol_l(10);
pts_controller_0_amphenol_int(9) <= pts_controller_0_amphenol_l(9);
pts_controller_0_amphenol_int(8) <= pts_controller_0_amphenol_l(8);
pts_controller_0_amphenol_int(7) <= pts_controller_0_amphenol_l(7);
pts_controller_0_amphenol_int(6) <= pts_controller_0_amphenol_l(6);
pts_controller_0_amphenol_int(5) <= pts_controller_0_amphenol_l(5);
pts_controller_0_amphenol_int(4) <= pts_controller_0_amphenol_l(4);
pts_controller_0_amphenol_int(3) <= pts_controller_0_amphenol_l(3);
pts_controller_0_amphenol_int(2) <= pts_controller_0_amphenol_l(2);
pts_controller_0_amphenol_int(1) <= pts_controller_0_amphenol_l(1);
pts_controller_0_amphenol_int(0) <= pts_controller_0_amphenol_l(0);


TOP_WITH_UART_1_M_MANAGER_1_LATCHER: process (clk, with_uart_1_reset) is
begin
    if (with_uart_1_reset = '1') then
        with_uart_1_m_manager_1_set_freq_latch <= to_signed(00000000, 31);
        with_uart_1_m_manager_1_set_step_f_latch <= to_unsigned(00000000, 30);
        with_uart_1_m_manager_1_set_step_t_latch <= to_unsigned(00000000, 30);
        with_uart_1_m_manager_1_set_wait_latch <= to_unsigned(00000000, 30);
    elsif rising_edge(clk) then
        if (bool(with_uart_1_ready) and bool(with_uart_1_start)) then
            with_uart_1_m_manager_1_set_freq_latch <= signed(resize(with_uart_1_set_freq, 31));
            with_uart_1_m_manager_1_set_step_f_latch <= resize(with_uart_1_freq_step, 30);
            with_uart_1_m_manager_1_set_step_t_latch <= resize(with_uart_1_time_step, 30);
            with_uart_1_m_manager_1_set_wait_latch <= resize(with_uart_1_hold_time, 30);
        end if;
    end if;
end process TOP_WITH_UART_1_M_MANAGER_1_LATCHER;

-- Our beloved finite state machine! For controlling the frequency stepping of the PTS.
-- It drives m_dec, which is a special counter that has both a binary output, and hexadecimal
-- output (which is what the PTS needs. It steps through the frequency schedule.
TOP_WITH_UART_1_M_MANAGER_1_FSM: process (with_uart_1_m_manager_1_state, clk, with_uart_1_start, with_uart_1_m_manager_1_quit_turnedon, with_uart_1_m_manager_1_dec_clk_int, with_uart_1_m_manager_1_add_o_int, with_uart_1_m_manager_1_sub_o_int, with_uart_1_m_manager_1_start_holding_turnedon) is
begin
    if ((with_uart_1_m_manager_1_state = WAIT) and (with_uart_1_start = '1')) then
        with_uart_1_dec_clk <= '0';
        with_uart_1_add <= '0';
        with_uart_1_sub <= '0';
        with_uart_1_m_manager_1_frequency_controller_en <= '0';
        with_uart_1_m_manager_1_waiter_en <= '0';
        with_uart_1_ready <= '1';
        with_uart_1_m_manager_1_state <= REACH_DESIRED;
    elsif ((with_uart_1_m_manager_1_state = REACH_DESIRED) and (not bool(with_uart_1_m_manager_1_quit_turnedon))) then
        with_uart_1_dec_clk <= with_uart_1_m_manager_1_dec_clk_int;
        with_uart_1_add <= with_uart_1_m_manager_1_add_o_int;
        with_uart_1_sub <= with_uart_1_m_manager_1_sub_o_int;
        with_uart_1_m_manager_1_frequency_controller_en <= '1';
        with_uart_1_m_manager_1_waiter_en <= '0';
        with_uart_1_ready <= '0';
    elsif ((with_uart_1_m_manager_1_state = REACH_DESIRED) and bool(with_uart_1_m_manager_1_quit_turnedon)) then
        with_uart_1_m_manager_1_state <= HOLD_FREQ;
    else
        if bool(with_uart_1_m_manager_1_start_holding_turnedon) then
            with_uart_1_m_manager_1_state <= WAIT;
        end if;
        with_uart_1_dec_clk <= '0';
        with_uart_1_add <= '0';
        with_uart_1_sub <= '0';
        with_uart_1_m_manager_1_frequency_controller_en <= '0';
        with_uart_1_m_manager_1_waiter_en <= '1';
        with_uart_1_ready <= '0';
    end if;
end process TOP_WITH_UART_1_M_MANAGER_1_FSM;


TOP_WITH_UART_1_M_MANAGER_1_FREQUENCY_CONTROLLER: process (with_uart_1_m_manager_1_freq_controller_clk, with_uart_1_reset) is
begin
    if (with_uart_1_reset = '1') then
        with_uart_1_m_manager_1_delta_freq <= to_unsigned(00000000, 30);
        with_uart_1_m_manager_1_quit <= '0';
        with_uart_1_m_manager_1_set_step_f_latch_int <= to_signed(00000000, 31);
        with_uart_1_m_manager_1_direction <= UP;
        with_uart_1_m_manager_1_set_freq_latch_int <= to_signed(00000000, 31);
        with_uart_1_m_manager_1_dec_clk_en <= '0';
        with_uart_1_incr <= to_unsigned(000, 9);
        with_uart_1_m_manager_1_add_o_int <= '0';
        with_uart_1_m_manager_1_sub_o_int <= '0';
    elsif rising_edge(with_uart_1_m_manager_1_freq_controller_clk) then
        for power in 0 to 9-1 loop
            if (signed(resize(with_uart_1_m_manager_1_set_step_f_latch, 31)) = power) then
                with_uart_1_m_manager_1_delta_freq <= to_unsigned(10 ** power, 30);
            end if;
        end loop;
        if (with_uart_1_m_manager_1_curr_freq > with_uart_1_m_manager_1_set_freq_latch) then
            with_uart_1_m_manager_1_quit <= '0';
            if (with_uart_1_m_manager_1_direction = UP) then
                if ((signed(resize(with_uart_1_m_manager_1_set_step_f_latch, 31)) + with_uart_1_m_manager_1_set_step_f_latch_int) >= 1) then
                    with_uart_1_m_manager_1_set_step_f_latch_int <= (with_uart_1_m_manager_1_set_step_f_latch_int - 1);
                end if;
                with_uart_1_m_manager_1_direction <= DOWN;
            else
                with_uart_1_m_manager_1_direction <= DOWN;
            end if;
        elsif (with_uart_1_m_manager_1_curr_freq < (with_uart_1_m_manager_1_set_freq_latch + with_uart_1_m_manager_1_set_freq_latch_int)) then
            with_uart_1_m_manager_1_quit <= '0';
            if (with_uart_1_m_manager_1_direction = DOWN) then
                if ((signed(resize(with_uart_1_m_manager_1_set_step_f_latch, 31)) + with_uart_1_m_manager_1_set_freq_latch_int) >= 1) then
                    with_uart_1_m_manager_1_set_freq_latch_int <= (with_uart_1_m_manager_1_set_freq_latch_int - 1);
                end if;
                with_uart_1_m_manager_1_direction <= UP;
            else
                with_uart_1_m_manager_1_direction <= UP;
            end if;
        else
            with_uart_1_m_manager_1_dec_clk_en <= '0';
            with_uart_1_incr <= to_unsigned(0, 9);
            with_uart_1_m_manager_1_add_o_int <= '0';
            with_uart_1_m_manager_1_sub_o_int <= '0';
            with_uart_1_m_manager_1_quit <= '1';
        end if;
        if (with_uart_1_m_manager_1_direction = UP) then
            with_uart_1_m_manager_1_add_o_int <= '1';
            with_uart_1_m_manager_1_sub_o_int <= '0';
            with_uart_1_incr <= resize(unsigned(signed(resize(with_uart_1_m_manager_1_set_step_f_latch, 31)) + with_uart_1_m_manager_1_set_freq_latch_int), 9);
            with_uart_1_m_manager_1_dec_clk_en <= '1';
        else
            with_uart_1_m_manager_1_add_o_int <= '0';
            with_uart_1_m_manager_1_sub_o_int <= '1';
            with_uart_1_incr <= resize(unsigned(signed(resize(with_uart_1_m_manager_1_set_step_f_latch, 31)) + with_uart_1_m_manager_1_set_freq_latch_int), 9);
            with_uart_1_m_manager_1_dec_clk_en <= '1';
        end if;
    end if;
end process TOP_WITH_UART_1_M_MANAGER_1_FREQUENCY_CONTROLLER;


TOP_WITH_UART_1_M_MANAGER_1_HOLDER: process (with_uart_1_m_manager_1_waiter_clk, with_uart_1_reset) is
begin
    if (with_uart_1_reset = '1') then
        with_uart_1_m_manager_1_start_holding <= '0';
        with_uart_1_m_manager_1_set_wait_latch_int <= to_signed(00000000, 31);
    elsif rising_edge(with_uart_1_m_manager_1_waiter_clk) then
        if ((signed(resize(with_uart_1_m_manager_1_set_wait_latch, 31)) + with_uart_1_m_manager_1_set_wait_latch_int) = 0) then
            with_uart_1_m_manager_1_start_holding <= '1';
        else
            with_uart_1_m_manager_1_start_holding <= '0';
            with_uart_1_m_manager_1_set_wait_latch_int <= (with_uart_1_m_manager_1_set_wait_latch_int - 1);
        end if;
    end if;
end process TOP_WITH_UART_1_M_MANAGER_1_HOLDER;



with_uart_1_m_manager_1_freq_controller_clk <= stdl(bool(with_uart_1_m_manager_1_frequency_controller_en) and bool(clk));
with_uart_1_m_manager_1_waiter_clk <= stdl(bool(with_uart_1_m_manager_1_waiter_en) and bool(clk));
with_uart_1_m_manager_1_dec_clk_int <= stdl(bool(with_uart_1_m_manager_1_dec_clk_en) and bool(clk));
with_uart_1_m_manager_1_curr_freq <= signed(resize(with_uart_1_curr_freq, 31));


TOP_WITH_UART_1_M_MANAGER_1_QUIT_MONITOR: process (clk, with_uart_1_reset) is
begin
    if (with_uart_1_reset = '1') then
        with_uart_1_m_manager_1_quitold <= '0';
        with_uart_1_m_manager_1_start_holdingold <= '0';
        with_uart_1_m_manager_1_quit_turnedon <= '0';
        with_uart_1_m_manager_1_start_holding_turnedon <= '0';
    elsif rising_edge(clk) then
        with_uart_1_m_manager_1_quitold <= with_uart_1_m_manager_1_quit;
        with_uart_1_m_manager_1_start_holdingold <= with_uart_1_m_manager_1_start_holdingold;
        if ((with_uart_1_m_manager_1_quitold = '0') and (with_uart_1_m_manager_1_quit = '1')) then
            with_uart_1_m_manager_1_quit_turnedon <= '1';
        else
            with_uart_1_m_manager_1_quit_turnedon <= '0';
        end if;
        if ((with_uart_1_m_manager_1_start_holdingold = '0') and (with_uart_1_m_manager_1_start_holding = '1')) then
            with_uart_1_m_manager_1_start_holding_turnedon <= '1';
        else
            with_uart_1_m_manager_1_start_holding_turnedon <= '0';
        end if;
    end if;
end process TOP_WITH_UART_1_M_MANAGER_1_QUIT_MONITOR;


TOP_WITH_UART_1_M_DEC_1_WIRING: process (with_uart_1_dec_clk) is
begin
    if rising_edge(with_uart_1_dec_clk) then
        hex_freq <= resize(with_uart_1_m_dec_1_q_int, 32);
        with_uart_1_curr_freq <= resize(unsigned(with_uart_1_m_dec_1_bq_int), 32);
    end if;
end process TOP_WITH_UART_1_M_DEC_1_WIRING;

-- This is the HEXADECIMAL counter.
-- It adds or subtracts only if (add xor sub) is True, to allow for the carry logic
-- a new bit of logic is required, namely addlogic, and sublogic. They give out 
-- lists of vectors (or integer masks). These are used in the logic below. And work 
-- out most of the stuff. One extra if statement is needed to increment the desired 
-- byte.
TOP_WITH_UART_1_M_DEC_1_HEX_COUNTER: process (with_uart_1_dec_clk, with_uart_1_reset) is
begin
    if (with_uart_1_reset = '1') then
        with_uart_1_m_dec_1_q_int_l(0) <= to_unsigned(0, 4);
        with_uart_1_m_dec_1_q_int_l(1) <= to_unsigned(0, 4);
        with_uart_1_m_dec_1_q_int_l(2) <= to_unsigned(0, 4);
        with_uart_1_m_dec_1_q_int_l(3) <= to_unsigned(0, 4);
        with_uart_1_m_dec_1_q_int_l(4) <= to_unsigned(0, 4);
        with_uart_1_m_dec_1_q_int_l(5) <= to_unsigned(0, 4);
        with_uart_1_m_dec_1_q_int_l(6) <= to_unsigned(0, 4);
        with_uart_1_m_dec_1_q_int_l(7) <= to_unsigned(0, 4);
        with_uart_1_m_dec_1_q_int_l(8) <= to_unsigned(0, 4);
    elsif falling_edge(with_uart_1_dec_clk) then
        if ((with_uart_1_add = '1') and (not bool(with_uart_1_sub))) then
            for digit in 1 to 9-1 loop
                if (digit > signed(resize(with_uart_1_incr, 10))) then
                    if bool(with_uart_1_m_dec_1_to_add(digit)) then
                        if (with_uart_1_m_dec_1_q_int_l(digit) /= 9) then
                            with_uart_1_m_dec_1_q_int_l(digit) <= (with_uart_1_m_dec_1_q_int_l(digit) + 1);
                        else
                            with_uart_1_m_dec_1_q_int_l(digit) <= to_unsigned(0, 4);
                        end if;
                    else
                        with_uart_1_m_dec_1_q_int_l(digit) <= with_uart_1_m_dec_1_q_int_l(digit);
                    end if;
                elsif (digit = signed(resize(with_uart_1_incr, 10))) then
                    if (with_uart_1_m_dec_1_q_int_l(to_integer(with_uart_1_incr)) /= 9) then
                        with_uart_1_m_dec_1_q_int_l(to_integer(with_uart_1_incr)) <= (with_uart_1_m_dec_1_q_int_l(to_integer(with_uart_1_incr)) + 1);
                    else
                        with_uart_1_m_dec_1_q_int_l(to_integer(with_uart_1_incr)) <= to_unsigned(0, 4);
                    end if;
                end if;
            end loop;
        elsif ((with_uart_1_sub = '1') and (not bool(with_uart_1_add))) then
            for digit in 1 to 9-1 loop
                if (digit > signed(resize(with_uart_1_incr, 10))) then
                    if bool(with_uart_1_m_dec_1_to_subtract(digit)) then
                        if (with_uart_1_m_dec_1_q_int_l(digit) /= 0) then
                            with_uart_1_m_dec_1_q_int_l(digit) <= (with_uart_1_m_dec_1_q_int_l(digit) - 1);
                        else
                            with_uart_1_m_dec_1_q_int_l(digit) <= to_unsigned(9, 4);
                        end if;
                    else
                        with_uart_1_m_dec_1_q_int_l(digit) <= with_uart_1_m_dec_1_q_int_l(digit);
                    end if;
                elsif (digit = signed(resize(with_uart_1_incr, 10))) then
                    if (with_uart_1_m_dec_1_q_int_l(to_integer(with_uart_1_incr)) /= 0) then
                        with_uart_1_m_dec_1_q_int_l(to_integer(with_uart_1_incr)) <= (with_uart_1_m_dec_1_q_int_l(to_integer(with_uart_1_incr)) - 1);
                    else
                        with_uart_1_m_dec_1_q_int_l(to_integer(with_uart_1_incr)) <= to_unsigned(9, 4);
                    end if;
                end if;
            end loop;
        else
            for digit in 0 to 9-1 loop
                with_uart_1_m_dec_1_q_int_l(digit) <= with_uart_1_m_dec_1_q_int_l(digit);
            end loop;
        end if;
    end if;
end process TOP_WITH_UART_1_M_DEC_1_HEX_COUNTER;

-- This module determines whether or not to add certain bits,
-- in the case of carry over. First we make sure we don't add all
-- the bits lower than increment, then we set the increment bit to add,
-- and lastly we perform the logic neccessary to determine if bits greater
-- than incr need to be added
-- 
-- It's sensitivity list is long, this is neccessary as to allow the logic 
-- to update to_add when any part of to_add changes, as is the case
-- when performing carry logic.
TOP_WITH_UART_1_M_DEC_1_ADDLOGIC: process (with_uart_1_incr, with_uart_1_m_dec_1_q_int, with_uart_1_m_dec_1_to_add(0), with_uart_1_m_dec_1_to_add(1), with_uart_1_m_dec_1_to_add(2), with_uart_1_m_dec_1_to_add(3), with_uart_1_m_dec_1_to_add(4), with_uart_1_m_dec_1_to_add(5), with_uart_1_m_dec_1_to_add(6), with_uart_1_m_dec_1_to_add(7), with_uart_1_m_dec_1_to_add(8)) is
begin
    for digit in 0 to 9-1 loop
        if (digit < signed(resize(with_uart_1_incr, 10))) then
            with_uart_1_m_dec_1_to_add(digit) <= '0';
        elsif (digit = signed(resize(with_uart_1_incr, 10))) then
            with_uart_1_m_dec_1_to_add(to_integer(with_uart_1_incr)) <= '1';
        else
            with_uart_1_m_dec_1_to_add(digit) <= stdl((with_uart_1_m_dec_1_q_int_l((digit - 1)) = 9) and bool(with_uart_1_m_dec_1_to_add((digit - 1))));
        end if;
    end loop;
end process TOP_WITH_UART_1_M_DEC_1_ADDLOGIC;

-- This module determines whether or not to subtract certain bits,
-- in the case of carry over. First we make sure we don't subtract all
-- the bits lower than increment, then we set the increment bit to subtract,
-- and lastly we perform the logic neccessary to determine if bits greater
-- than incr need to be subtracted.
-- 
-- It's sensitivity list is long, this is neccessary as to allow the logic 
-- to update to_subtract when any part of to_subtract changes, as is the case
-- when performing carry logic.
TOP_WITH_UART_1_M_DEC_1_SUBLOGIC: process (with_uart_1_incr, with_uart_1_m_dec_1_q_int, with_uart_1_m_dec_1_to_subtract(0), with_uart_1_m_dec_1_to_subtract(1), with_uart_1_m_dec_1_to_subtract(2), with_uart_1_m_dec_1_to_subtract(3), with_uart_1_m_dec_1_to_subtract(4), with_uart_1_m_dec_1_to_subtract(5), with_uart_1_m_dec_1_to_subtract(6), with_uart_1_m_dec_1_to_subtract(7), with_uart_1_m_dec_1_to_subtract(8)) is
begin
    for digit in 0 to 9-1 loop
        if (digit < signed(resize(with_uart_1_incr, 10))) then
            with_uart_1_m_dec_1_to_subtract(digit) <= '0';
        elsif (digit = signed(resize(with_uart_1_incr, 10))) then
            with_uart_1_m_dec_1_to_subtract(to_integer(with_uart_1_incr)) <= '1';
        else
            with_uart_1_m_dec_1_to_subtract(digit) <= stdl((with_uart_1_m_dec_1_q_int_l((digit - 1)) = 0) and bool(with_uart_1_m_dec_1_to_subtract((digit - 1))));
        end if;
    end loop;
end process TOP_WITH_UART_1_M_DEC_1_SUBLOGIC;

-- Here is the binary counter for bq. 
-- It's value should synchronously be the same
-- as q. This logic should be simple, and it is,
-- but it freaks out when you subtract too far. Be warned!
TOP_WITH_UART_1_M_DEC_1_BIN_COUNTER: process (with_uart_1_dec_clk, with_uart_1_reset) is
begin
    if (with_uart_1_reset = '1') then
        with_uart_1_m_dec_1_bq_int <= to_signed(00000000, 31);
    elsif falling_edge(with_uart_1_dec_clk) then
        if (bool(with_uart_1_add) and (not bool(with_uart_1_sub))) then
            with_uart_1_m_dec_1_bq_int <= (with_uart_1_m_dec_1_bq_int + signed(resize(with_uart_1_m_dec_1_increment, 31)));
        elsif (bool(with_uart_1_sub) and (not bool(with_uart_1_add))) then
            with_uart_1_m_dec_1_bq_int <= (with_uart_1_m_dec_1_bq_int - signed(resize(with_uart_1_m_dec_1_increment, 31)));
        else
            with_uart_1_m_dec_1_bq_int <= with_uart_1_m_dec_1_bq_int;
        end if;
    end if;
end process TOP_WITH_UART_1_M_DEC_1_BIN_COUNTER;


TOP_WITH_UART_1_M_DEC_1_ROM_1_READ: process (with_uart_1_incr) is
begin
    case to_integer(with_uart_1_incr) is
        when 0 => with_uart_1_m_dec_1_increment <= "000000000000000000000000000001";
        when 1 => with_uart_1_m_dec_1_increment <= "000000000000000000000000001010";
        when 2 => with_uart_1_m_dec_1_increment <= "000000000000000000000001100100";
        when 3 => with_uart_1_m_dec_1_increment <= "000000000000000000001111101000";
        when 4 => with_uart_1_m_dec_1_increment <= "000000000000000010011100010000";
        when 5 => with_uart_1_m_dec_1_increment <= "000000000000011000011010100000";
        when 6 => with_uart_1_m_dec_1_increment <= "000000000011110100001001000000";
        when 7 => with_uart_1_m_dec_1_increment <= "000000100110001001011010000000";
        when others => with_uart_1_m_dec_1_increment <= "000101111101011110000100000000";
    end case;
end process TOP_WITH_UART_1_M_DEC_1_ROM_1_READ;


TOP_WITH_UART_1_UART_1_CHECKFORENDBITS: process (with_uart_1_uart_1_baud) is
begin
    if rising_edge(with_uart_1_uart_1_baud) then
        if (not bool(with_uart_1_uart_1_started)) then
            if (fpga_rx = '0') then
                if (with_uart_1_uart_1_bauds_held_down /= 4) then
                    with_uart_1_uart_1_bauds_held_down <= (with_uart_1_uart_1_bauds_held_down + 1);
                    with_uart_1_uart_1_latch_en <= '0';
                else
                    with_uart_1_uart_1_bauds_held_down <= to_unsigned(0, 3);
                    with_uart_1_uart_1_started <= '1';
                    with_uart_1_uart_1_latch_en <= '1';
                end if;
            else
                with_uart_1_uart_1_latch_en <= '0';
                with_uart_1_uart_1_bauds_held_down <= to_unsigned(0, 3);
            end if;
        else
            if (with_uart_1_uart_1_bits_received = 8) then
                with_uart_1_uart_1_latch_en <= '0';
            else
                with_uart_1_uart_1_latch_en <= '1';
            end if;
            if ((fpga_rx = '1') and (with_uart_1_uart_1_bits_received = 8)) then
                if (signed(resize(with_uart_1_uart_1_bauds_held_down, 4)) /= (4 + ((1 - 1) * 8))) then
                    with_uart_1_uart_1_bauds_held_down <= (with_uart_1_uart_1_bauds_held_down + 1);
                else
                    with_uart_1_uart_1_bauds_held_down <= to_unsigned(0, 3);
                    with_uart_1_uart_1_started <= '0';
                end if;
            elsif (with_uart_1_uart_1_bits_received = 8) then
                with_uart_1_uart_1_bauds_held_down <= to_unsigned(0, 3);
            end if;
        end if;
    end if;
end process TOP_WITH_UART_1_UART_1_CHECKFORENDBITS;



with_uart_1_uart_1_slowbaud_rst <= stdl((not bool(with_uart_1_uart_1_started)));
with_uart_1_drdy <= stdl((not bool(with_uart_1_uart_1_started)));


TOP_WITH_UART_1_UART_1_COUNTTHEMBITS: process (with_uart_1_uart_1_slowbaud, with_uart_1_uart_1_slowbaud_rst) is
begin
    if (with_uart_1_uart_1_slowbaud_rst = '1') then
        with_uart_1_uart_1_bits_received <= to_unsigned(00, 5);
    elsif rising_edge(with_uart_1_uart_1_slowbaud) then
        if bool(with_uart_1_uart_1_latch_en) then
            with_uart_1_uart_1_bits_received <= (with_uart_1_uart_1_bits_received + 1);
        end if;
    end if;
end process TOP_WITH_UART_1_UART_1_COUNTTHEMBITS;


TOP_WITH_UART_1_UART_1_CLKDIV_2_CLOCKDIVIDER: process (clk) is
begin
    if rising_edge(clk) then
        if ((signed(resize(with_uart_1_uart_1_clkdiv_2_counter, 9)) = (156 - 1)) or (signed(resize(with_uart_1_uart_1_clkdiv_2_counter, 9)) = (156 / 2))) then
            with_uart_1_uart_1_clkdiv_2_clk_new <= stdl((not bool(with_uart_1_uart_1_clkdiv_2_clk_new)));
        end if;
        if (signed(resize(with_uart_1_uart_1_clkdiv_2_counter, 9)) = (156 - 1)) then
            with_uart_1_uart_1_clkdiv_2_counter <= to_unsigned(0, 8);
        else
            with_uart_1_uart_1_clkdiv_2_counter <= (with_uart_1_uart_1_clkdiv_2_counter + 1);
        end if;
    end if;
end process TOP_WITH_UART_1_UART_1_CLKDIV_2_CLOCKDIVIDER;



with_uart_1_uart_1_baud <= with_uart_1_uart_1_clkdiv_2_clk_new;


TOP_WITH_UART_1_UART_1_CLKDIV_3_CLOCKDIVIDER: process (with_uart_1_uart_1_baud, with_uart_1_uart_1_slowbaud_rst) is
begin
    if (with_uart_1_uart_1_slowbaud_rst = '1') then
        with_uart_1_uart_1_clkdiv_3_clk_new <= '0';
        with_uart_1_uart_1_clkdiv_3_counter <= to_unsigned(0, 3);
    elsif rising_edge(with_uart_1_uart_1_baud) then
        if ((signed(resize(with_uart_1_uart_1_clkdiv_3_counter, 4)) = (8 - 1)) or (signed(resize(with_uart_1_uart_1_clkdiv_3_counter, 4)) = (8 / 2))) then
            with_uart_1_uart_1_clkdiv_3_clk_new <= stdl((not bool(with_uart_1_uart_1_clkdiv_3_clk_new)));
        end if;
        if (signed(resize(with_uart_1_uart_1_clkdiv_3_counter, 4)) = (8 - 1)) then
            with_uart_1_uart_1_clkdiv_3_counter <= to_unsigned(0, 3);
        else
            with_uart_1_uart_1_clkdiv_3_counter <= (with_uart_1_uart_1_clkdiv_3_counter + 1);
        end if;
    end if;
end process TOP_WITH_UART_1_UART_1_CLKDIV_3_CLOCKDIVIDER;



with_uart_1_uart_1_slowbaud <= with_uart_1_uart_1_clkdiv_3_clk_new;


TOP_WITH_UART_1_UART_1_SHIFTREG_1_WIRING: process (with_uart_1_uart_1_slowbaud, with_uart_1_uart_1_latch_en) is
begin
    for i in 0 to 8-1 loop
        with_uart_1_uart_1_shiftreg_1_clk_int <= stdl(bool(with_uart_1_uart_1_slowbaud) and bool(with_uart_1_uart_1_latch_en));
    end loop;
end process TOP_WITH_UART_1_UART_1_SHIFTREG_1_WIRING;


TOP_WITH_UART_1_UART_1_SHIFTREG_1_LATCHER: process (with_uart_1_uart_1_shiftreg_1_clk_int) is
    variable loadval: signed(-1 downto 0);
begin
    if rising_edge(with_uart_1_uart_1_shiftreg_1_clk_int) then
        if ('0' = '0') then
            with_uart_1_uart_1_shiftreg_1_latches(0) <= fpga_rx;
            for i in 1 to 8-1 loop
                with_uart_1_uart_1_shiftreg_1_latches(i) <= with_uart_1_uart_1_shiftreg_1_latches((i - 1));
            end loop;
        else
            for i in 0 to 8-1 loop
                with_uart_1_uart_1_shiftreg_1_latches(i) <= loadval(i);
            end loop;
        end if;
    end if;
end process TOP_WITH_UART_1_UART_1_SHIFTREG_1_LATCHER;



with_uart_1_rx_data <= with_uart_1_uart_1_shiftreg_1_par_int;


TOP_WITH_UART_1_BUSSEDRAM_4_WRITE: process (with_uart_1_freq_rambus_clk) is
begin
    if rising_edge(with_uart_1_freq_rambus_clk) then
        if bool(with_uart_1_bussedram_4_rambus_we) then
            with_uart_1_bussedram_4_mem(to_integer(with_uart_1_freq_rambus_addr_renamed0)) <= with_uart_1_freq_rambus_din;
        end if;
    end if;
end process TOP_WITH_UART_1_BUSSEDRAM_4_WRITE;



with_uart_1_freq_rambus_dout <= with_uart_1_bussedram_4_mem(to_integer(with_uart_1_freq_rambus_addr_renamed0));


TOP_WITH_UART_1_BUSSEDRAM_5_WRITE: process (with_uart_1_fstep_rambus_clk) is
begin
    if rising_edge(with_uart_1_fstep_rambus_clk) then
        if bool(with_uart_1_bussedram_5_rambus_we) then
            with_uart_1_bussedram_5_mem(to_integer(with_uart_1_fstep_rambus_addr_renamed0)) <= with_uart_1_fstep_rambus_din;
        end if;
    end if;
end process TOP_WITH_UART_1_BUSSEDRAM_5_WRITE;



with_uart_1_fstep_rambus_dout <= with_uart_1_bussedram_5_mem(to_integer(with_uart_1_fstep_rambus_addr_renamed0));


TOP_WITH_UART_1_BUSSEDRAM_6_WRITE: process (with_uart_1_tstep_rambus_clk) is
begin
    if rising_edge(with_uart_1_tstep_rambus_clk) then
        if bool(with_uart_1_bussedram_6_rambus_we) then
            with_uart_1_bussedram_6_mem(to_integer(with_uart_1_tstep_rambus_addr_renamed0)) <= with_uart_1_tstep_rambus_din;
        end if;
    end if;
end process TOP_WITH_UART_1_BUSSEDRAM_6_WRITE;



with_uart_1_tstep_rambus_dout <= with_uart_1_bussedram_6_mem(to_integer(with_uart_1_tstep_rambus_addr_renamed0));


TOP_WITH_UART_1_BUSSEDRAM_7_WRITE: process (with_uart_1_hold_rambus_clk) is
begin
    if rising_edge(with_uart_1_hold_rambus_clk) then
        if bool(with_uart_1_bussedram_7_rambus_we) then
            with_uart_1_bussedram_7_mem(to_integer(with_uart_1_hold_rambus_addr_renamed0)) <= with_uart_1_hold_rambus_din;
        end if;
    end if;
end process TOP_WITH_UART_1_BUSSEDRAM_7_WRITE;



with_uart_1_hold_rambus_dout <= with_uart_1_bussedram_7_mem(to_integer(with_uart_1_hold_rambus_addr_renamed0));


TOP_WITH_UART_1_SCHEDULE_ARBITER: process (clk, with_uart_1_reset) is
begin
    if (with_uart_1_reset = '1') then
        with_uart_1_start <= '0';
        with_uart_1_sched_index <= to_unsigned(00, 8);
        with_uart_1_done <= '0';
    elsif rising_edge(clk) then
        if (with_uart_1_ready = '1') then
            with_uart_1_start <= stdl((True and (not bool(with_uart_1_done))) and bool(trigger));
            if (signed(resize(with_uart_1_sched_index, 9)) < (signed(resize(with_uart_1_sched_len, 8)) - 1)) then
                with_uart_1_sched_index <= (with_uart_1_sched_index + 1);
            else
                with_uart_1_done <= '1';
            end if;
        else
            with_uart_1_start <= '0';
        end if;
    end if;
end process TOP_WITH_UART_1_SCHEDULE_ARBITER;

-- This fsm latches (just after) the dataready positive edge
-- signal. The data is guaranteed to be ready then.
TOP_WITH_UART_1_COMMS_ARBITER_0_FSM: process (clk, with_uart_1_reset) is
begin
    if (with_uart_1_reset = '1') then
        with_uart_1_bussedram_4_rambus_we <= '0';
        with_uart_1_bussedram_5_rambus_we <= '0';
        with_uart_1_bussedram_6_rambus_we <= '0';
        with_uart_1_bussedram_7_rambus_we <= '0';
        with_uart_1_whichram <= to_unsigned(00, 8);
        with_uart_1_state <= READWHICHRAM;
        with_uart_1_comms_arbiter_0_latch_counter <= to_unsigned(00, 8);
        with_uart_1_biggestblock_l(0) <= '0';
        with_uart_1_biggestblock_l(1) <= '0';
        with_uart_1_biggestblock_l(2) <= '0';
        with_uart_1_biggestblock_l(3) <= '0';
        with_uart_1_biggestblock_l(4) <= '0';
        with_uart_1_biggestblock_l(5) <= '0';
        with_uart_1_biggestblock_l(6) <= '0';
        with_uart_1_biggestblock_l(7) <= '0';
        with_uart_1_biggestblock_l(8) <= '0';
        with_uart_1_biggestblock_l(9) <= '0';
        with_uart_1_biggestblock_l(10) <= '0';
        with_uart_1_biggestblock_l(11) <= '0';
        with_uart_1_biggestblock_l(12) <= '0';
        with_uart_1_biggestblock_l(13) <= '0';
        with_uart_1_biggestblock_l(14) <= '0';
        with_uart_1_biggestblock_l(15) <= '0';
        with_uart_1_biggestblock_l(16) <= '0';
        with_uart_1_biggestblock_l(17) <= '0';
        with_uart_1_biggestblock_l(18) <= '0';
        with_uart_1_biggestblock_l(19) <= '0';
        with_uart_1_biggestblock_l(20) <= '0';
        with_uart_1_biggestblock_l(21) <= '0';
        with_uart_1_biggestblock_l(22) <= '0';
        with_uart_1_biggestblock_l(23) <= '0';
        with_uart_1_biggestblock_l(24) <= '0';
        with_uart_1_biggestblock_l(25) <= '0';
        with_uart_1_biggestblock_l(26) <= '0';
        with_uart_1_biggestblock_l(27) <= '0';
        with_uart_1_biggestblock_l(28) <= '0';
        with_uart_1_biggestblock_l(29) <= '0';
        with_uart_1_biggestblock_l(30) <= '0';
        with_uart_1_biggestblock_l(31) <= '0';
        with_uart_1_freq_rambus_length <= to_unsigned(00, 8);
        with_uart_1_freq_rambus_addr <= to_unsigned(00, 8);
        with_uart_1_fstep_rambus_length <= to_unsigned(00, 8);
        with_uart_1_fstep_rambus_addr <= to_unsigned(00, 8);
        with_uart_1_tstep_rambus_length <= to_unsigned(00, 8);
        with_uart_1_tstep_rambus_addr <= to_unsigned(00, 8);
        with_uart_1_hold_rambus_length <= to_unsigned(00, 8);
        with_uart_1_hold_rambus_addr <= to_unsigned(00, 8);
        with_uart_1_reset <= '0';
    elsif rising_edge(clk) then
        if ((with_uart_1_state = READWHICHRAM) and bool(with_uart_1_comms_arbiter_0_drdy_turnedon)) then
            with_uart_1_bussedram_4_rambus_we <= '0';
            with_uart_1_bussedram_5_rambus_we <= '0';
            with_uart_1_bussedram_6_rambus_we <= '0';
            with_uart_1_bussedram_7_rambus_we <= '0';
            with_uart_1_whichram <= with_uart_1_rx_data;
            if (with_uart_1_rx_data /= 255) then
                with_uart_1_state <= PARSEFORRAM;
            else
                with_uart_1_state <= RESET;
            end if;
        elsif ((with_uart_1_state = PARSEFORRAM) and bool(with_uart_1_comms_arbiter_0_drdy_turnedon)) then
            with_uart_1_comms_arbiter_0_latch_counter <= (with_uart_1_comms_arbiter_0_latch_counter + 1);
            for i in 0 to 8-1 loop
                with_uart_1_biggestblock_l(to_integer(i + signed(resize(8 * with_uart_1_comms_arbiter_0_latch_counter, 17)))) <= with_uart_1_rx_data(i);
            end loop;
            if (with_uart_1_comms_arbiter_0_latch_counter = 3) then
                with_uart_1_comms_arbiter_0_latch_counter <= to_unsigned(0, 8);
                with_uart_1_state <= SENDTORAM;
            end if;
        elsif (with_uart_1_state = SENDTORAM) then
            case with_uart_1_whichram is
                when "00000000" =>
                    with_uart_1_bussedram_4_rambus_we <= '1';
                    with_uart_1_freq_rambus_length <= (with_uart_1_freq_rambus_length + 1);
                    with_uart_1_freq_rambus_addr <= (with_uart_1_freq_rambus_addr + 1);
                when "00000001" =>
                    with_uart_1_bussedram_5_rambus_we <= '1';
                    with_uart_1_fstep_rambus_length <= (with_uart_1_fstep_rambus_length + 1);
                    with_uart_1_fstep_rambus_addr <= (with_uart_1_fstep_rambus_addr + 1);
                when "00000010" =>
                    with_uart_1_bussedram_6_rambus_we <= '1';
                    with_uart_1_tstep_rambus_length <= (with_uart_1_tstep_rambus_length + 1);
                    with_uart_1_tstep_rambus_addr <= (with_uart_1_tstep_rambus_addr + 1);
                when "00000011" =>
                    with_uart_1_bussedram_7_rambus_we <= '1';
                    with_uart_1_hold_rambus_length <= (with_uart_1_hold_rambus_length + 1);
                    with_uart_1_hold_rambus_addr <= (with_uart_1_hold_rambus_addr + 1);
                when others =>
                    with_uart_1_bussedram_4_rambus_we <= '0';
                    with_uart_1_bussedram_5_rambus_we <= '0';
                    with_uart_1_bussedram_6_rambus_we <= '0';
                    with_uart_1_bussedram_7_rambus_we <= '0';
            end case;
            with_uart_1_state <= READWHICHRAM;
        else
            with_uart_1_reset <= '1';
        end if;
    end if;
end process TOP_WITH_UART_1_COMMS_ARBITER_0_FSM;

-- This is a little block for determining whether 
-- drdy has transitioned in the last clock cycle.
-- It effectively turns the drdy step function into 
-- a hat function.
TOP_WITH_UART_1_COMMS_ARBITER_0_DRDY_MONITOR: process (clk, with_uart_1_reset) is
begin
    if (with_uart_1_reset = '1') then
        with_uart_1_comms_arbiter_0_drdy_old <= '0';
        with_uart_1_comms_arbiter_0_drdy_turnedon <= '0';
    elsif rising_edge(clk) then
        with_uart_1_comms_arbiter_0_drdy_old <= with_uart_1_drdy;
        if ((with_uart_1_drdy /= with_uart_1_comms_arbiter_0_drdy_old) and (with_uart_1_comms_arbiter_0_drdy_old = '0')) then
            with_uart_1_comms_arbiter_0_drdy_turnedon <= '1';
        else
            with_uart_1_comms_arbiter_0_drdy_turnedon <= '0';
        end if;
    end if;
end process TOP_WITH_UART_1_COMMS_ARBITER_0_DRDY_MONITOR;

-- Just connect the notclock signal for passing into the RAMs  

with_uart_1_notclock <= stdl((not bool(clk)));

-- Some nasty combinatorial logic here to determine
-- the schedule length
TOP_WITH_UART_1_DETERMINE_SCHED_LEN: process (with_uart_1_freq_rambus_length, with_uart_1_fstep_rambus_length, with_uart_1_tstep_rambus_length, with_uart_1_hold_rambus_length, with_uart_1_drdy) is
begin
    if ((with_uart_1_freq_rambus_length < with_uart_1_fstep_rambus_length) and (with_uart_1_freq_rambus_length < with_uart_1_tstep_rambus_length) and (with_uart_1_freq_rambus_length < with_uart_1_hold_rambus_length)) then
        with_uart_1_sched_len <= resize(with_uart_1_freq_rambus_length, 7);
    elsif ((with_uart_1_tstep_rambus_length < with_uart_1_fstep_rambus_length) and (with_uart_1_tstep_rambus_length < with_uart_1_freq_rambus_length) and (with_uart_1_tstep_rambus_length < with_uart_1_hold_rambus_length)) then
        with_uart_1_sched_len <= resize(with_uart_1_tstep_rambus_length, 7);
    elsif ((with_uart_1_hold_rambus_length < with_uart_1_fstep_rambus_length) and (with_uart_1_hold_rambus_length < with_uart_1_freq_rambus_length) and (with_uart_1_hold_rambus_length < with_uart_1_tstep_rambus_length)) then
        with_uart_1_sched_len <= resize(with_uart_1_hold_rambus_length, 7);
    else
        with_uart_1_sched_len <= resize(with_uart_1_fstep_rambus_length, 7);
    end if;
end process TOP_WITH_UART_1_DETERMINE_SCHED_LEN;

-- Connect basic signals of the RAMS: data in and data_out and clock
TOP_WITH_UART_1_RAMWIRING: process (clk, with_uart_1_reset) is
begin
    if (with_uart_1_reset = '1') then
        with_uart_1_freq_rambus_din <= to_unsigned(00000000, 32);
        with_uart_1_fstep_rambus_din <= to_unsigned(00000000, 32);
        with_uart_1_tstep_rambus_din <= to_unsigned(00000000, 32);
        with_uart_1_hold_rambus_din <= to_unsigned(00000000, 32);
        with_uart_1_set_freq <= to_unsigned(00000000, 32);
        with_uart_1_freq_step <= to_unsigned(00000000, 32);
        with_uart_1_time_step <= to_unsigned(00000000, 32);
        with_uart_1_hold_time <= to_unsigned(00000000, 32);
        with_uart_1_freq_rambus_clk <= '0';
        with_uart_1_fstep_rambus_clk <= '0';
        with_uart_1_tstep_rambus_clk <= '0';
        with_uart_1_hold_rambus_clk <= '0';
        with_uart_1_freq_rambus_addr_renamed0 <= to_unsigned(00, 7);
        with_uart_1_fstep_rambus_addr_renamed0 <= to_unsigned(00, 7);
        with_uart_1_tstep_rambus_addr_renamed0 <= to_unsigned(00, 7);
        with_uart_1_hold_rambus_addr_renamed0 <= to_unsigned(00, 7);
    elsif rising_edge(clk) then
        for i in 0 to 32-1 loop
            with_uart_1_freq_rambus_din <= with_uart_1_biggestblock(32-1 downto 0);
            with_uart_1_fstep_rambus_din <= with_uart_1_biggestblock(32-1 downto 0);
            with_uart_1_tstep_rambus_din <= with_uart_1_biggestblock(32-1 downto 0);
            with_uart_1_hold_rambus_din <= with_uart_1_biggestblock(32-1 downto 0);
        end loop;
        with_uart_1_set_freq <= with_uart_1_freq_rambus_dout;
        with_uart_1_freq_step <= with_uart_1_fstep_rambus_dout;
        with_uart_1_time_step <= with_uart_1_tstep_rambus_dout;
        with_uart_1_hold_time <= with_uart_1_hold_rambus_dout;
        with_uart_1_freq_rambus_clk <= with_uart_1_notclock;
        with_uart_1_fstep_rambus_clk <= with_uart_1_notclock;
        with_uart_1_tstep_rambus_clk <= with_uart_1_notclock;
        with_uart_1_hold_rambus_clk <= with_uart_1_notclock;
        if (with_uart_1_state = READWHICHRAM) then
            with_uart_1_freq_rambus_addr_renamed0 <= resize(with_uart_1_sched_index, 7);
            with_uart_1_fstep_rambus_addr_renamed0 <= resize(with_uart_1_sched_index, 7);
            with_uart_1_tstep_rambus_addr_renamed0 <= resize(with_uart_1_sched_index, 7);
            with_uart_1_hold_rambus_addr_renamed0 <= resize(with_uart_1_sched_index, 7);
        else
            with_uart_1_freq_rambus_addr_renamed0 <= resize(with_uart_1_freq_rambus_addr, 7);
            with_uart_1_fstep_rambus_addr_renamed0 <= resize(with_uart_1_fstep_rambus_addr, 7);
            with_uart_1_tstep_rambus_addr_renamed0 <= resize(with_uart_1_tstep_rambus_addr, 7);
            with_uart_1_hold_rambus_addr_renamed0 <= resize(with_uart_1_hold_rambus_addr, 7);
        end if;
    end if;
end process TOP_WITH_UART_1_RAMWIRING;



amphenol <= pts_controller_0_amphenol_int;
pts_controller_0_amphenol_l(49) <= '0';
pts_controller_0_amphenol_l(48) <= '1';
pts_controller_0_amphenol_l(41) <= stdl((not True));
pts_controller_0_amphenol_l(20) <= '0';
pts_controller_0_amphenol_l(21) <= '0';
pts_controller_0_amphenol_l(22) <= '1';
pts_controller_0_amphenol_l(23) <= '1';
pts_controller_0_amphenol_l(24) <= '1';
pts_controller_0_amphenol_l(45) <= '1';
pts_controller_0_amphenol_l(46) <= '1';
pts_controller_0_amphenol_l(43) <= stdl((not bool(hex_freq(33))));
pts_controller_0_amphenol_l(42) <= stdl((not bool(hex_freq(32))));
pts_controller_0_amphenol_l(40) <= stdl((not bool(hex_freq(31))));
pts_controller_0_amphenol_l(39) <= stdl((not bool(hex_freq(30))));
pts_controller_0_amphenol_l(15) <= stdl((not bool(hex_freq(29))));
pts_controller_0_amphenol_l(14) <= stdl((not bool(hex_freq(28))));
pts_controller_0_amphenol_l(19) <= stdl((not bool(hex_freq(27))));
pts_controller_0_amphenol_l(18) <= stdl((not bool(hex_freq(26))));
pts_controller_0_amphenol_l(17) <= stdl((not bool(hex_freq(25))));
pts_controller_0_amphenol_l(16) <= stdl((not bool(hex_freq(24))));
pts_controller_0_amphenol_l(26) <= stdl((not bool(hex_freq(23))));
pts_controller_0_amphenol_l(25) <= stdl((not bool(hex_freq(22))));
pts_controller_0_amphenol_l(1) <= stdl((not bool(hex_freq(21))));
pts_controller_0_amphenol_l(0) <= stdl((not bool(hex_freq(20))));
pts_controller_0_amphenol_l(28) <= stdl((not bool(hex_freq(19))));
pts_controller_0_amphenol_l(27) <= stdl((not bool(hex_freq(18))));
pts_controller_0_amphenol_l(3) <= stdl((not bool(hex_freq(17))));
pts_controller_0_amphenol_l(2) <= stdl((not bool(hex_freq(16))));
pts_controller_0_amphenol_l(30) <= stdl((not bool(hex_freq(15))));
pts_controller_0_amphenol_l(29) <= stdl((not bool(hex_freq(14))));
pts_controller_0_amphenol_l(5) <= stdl((not bool(hex_freq(13))));
pts_controller_0_amphenol_l(4) <= stdl((not bool(hex_freq(12))));
pts_controller_0_amphenol_l(32) <= stdl((not bool(hex_freq(11))));
pts_controller_0_amphenol_l(31) <= stdl((not bool(hex_freq(10))));
pts_controller_0_amphenol_l(7) <= stdl((not bool(hex_freq(9))));
pts_controller_0_amphenol_l(6) <= stdl((not bool(hex_freq(8))));
pts_controller_0_amphenol_l(34) <= stdl((not bool(hex_freq(7))));
pts_controller_0_amphenol_l(33) <= stdl((not bool(hex_freq(6))));
pts_controller_0_amphenol_l(9) <= stdl((not bool(hex_freq(5))));
pts_controller_0_amphenol_l(8) <= stdl((not bool(hex_freq(4))));
pts_controller_0_amphenol_l(36) <= stdl((not bool(hex_freq(3))));
pts_controller_0_amphenol_l(35) <= stdl((not bool(hex_freq(2))));
pts_controller_0_amphenol_l(11) <= stdl((not bool(hex_freq(1))));
pts_controller_0_amphenol_l(10) <= stdl((not bool(hex_freq(0))));
pts_controller_0_amphenol_l(38) <= '0';
pts_controller_0_amphenol_l(37) <= '1';
pts_controller_0_amphenol_l(13) <= '1';
pts_controller_0_amphenol_l(12) <= '1';

end architecture MyHDL;
