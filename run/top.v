// File: top.v
// Generated by MyHDL 1.0dev
// Date: Wed Jul 13 20:12:13 2016


`timescale 1ns/10ps

module top (
    clk,
    trigger,
    fpga_rx,
    fpga_tx,
    amphenol
);


input clk;
input trigger;
input fpga_rx;
input fpga_tx;
output [49:0] amphenol;
wire [49:0] amphenol;

reg [31:0] hex_freq;
reg [31:0] with_uart_1_curr_freq;
reg with_uart_1_add;
reg with_uart_1_sub;
reg with_uart_1_dec_clk;
reg [8:0] with_uart_1_incr;
reg [6:0] with_uart_1_sched_len;
reg [31:0] with_uart_1_set_freq;
reg [31:0] with_uart_1_freq_step;
reg [31:0] with_uart_1_time_step;
reg [31:0] with_uart_1_hold_time;
reg [7:0] with_uart_1_sched_index;
reg with_uart_1_reset;
wire with_uart_1_notclock;
reg with_uart_1_start;
reg with_uart_1_ready;
reg with_uart_1_done;
reg [7:0] with_uart_1_whichram;
wire [31:0] with_uart_1_biggestblock;
reg [1:0] with_uart_1_state;
wire [7:0] with_uart_1_rx_data;
wire with_uart_1_drdy;
reg [7:0] with_uart_1_freq_rambus_addr;
reg [7:0] with_uart_1_fstep_rambus_addr;
reg [7:0] with_uart_1_tstep_rambus_addr;
reg [7:0] with_uart_1_hold_rambus_addr;
reg [7:0] with_uart_1_freq_rambus_length;
reg [7:0] with_uart_1_fstep_rambus_length;
reg [7:0] with_uart_1_tstep_rambus_length;
reg [7:0] with_uart_1_hold_rambus_length;
reg [31:0] with_uart_1_freq_rambus_din;
reg [31:0] with_uart_1_fstep_rambus_din;
reg [31:0] with_uart_1_tstep_rambus_din;
reg [31:0] with_uart_1_hold_rambus_din;
wire [31:0] with_uart_1_freq_rambus_dout;
wire [31:0] with_uart_1_fstep_rambus_dout;
wire [31:0] with_uart_1_tstep_rambus_dout;
wire [31:0] with_uart_1_hold_rambus_dout;
reg with_uart_1_freq_rambus_clk;
reg with_uart_1_fstep_rambus_clk;
reg with_uart_1_tstep_rambus_clk;
reg with_uart_1_hold_rambus_clk;
reg [6:0] with_uart_1_freq_rambus_addr_renamed0;
reg [6:0] with_uart_1_fstep_rambus_addr_renamed0;
reg [6:0] with_uart_1_tstep_rambus_addr_renamed0;
reg [6:0] with_uart_1_hold_rambus_addr_renamed0;
wire signed [30:0] with_uart_1_m_manager_1_curr_freq;
reg signed [30:0] with_uart_1_m_manager_1_set_freq_latch;
reg [29:0] with_uart_1_m_manager_1_set_step_f_latch;
reg [29:0] with_uart_1_m_manager_1_set_step_t_latch;
reg [29:0] with_uart_1_m_manager_1_set_wait_latch;
reg signed [30:0] with_uart_1_m_manager_1_set_freq_latch_int;
reg signed [30:0] with_uart_1_m_manager_1_set_step_f_latch_int;
reg signed [30:0] with_uart_1_m_manager_1_set_wait_latch_int;
reg with_uart_1_m_manager_1_frequency_controller_en;
reg with_uart_1_m_manager_1_waiter_en;
reg with_uart_1_m_manager_1_quit;
reg with_uart_1_m_manager_1_start_holding;
reg with_uart_1_m_manager_1_quit_turnedon;
reg with_uart_1_m_manager_1_start_holding_turnedon;
reg [1:0] with_uart_1_m_manager_1_state;
reg with_uart_1_m_manager_1_add_o_int;
reg with_uart_1_m_manager_1_sub_o_int;
wire with_uart_1_m_manager_1_dec_clk_int;
reg [29:0] with_uart_1_m_manager_1_delta_freq;
reg [0:0] with_uart_1_m_manager_1_direction;
reg with_uart_1_m_manager_1_dec_clk_en;
wire with_uart_1_m_manager_1_freq_controller_clk;
wire with_uart_1_m_manager_1_waiter_clk;
reg with_uart_1_m_manager_1_quitold;
reg with_uart_1_m_manager_1_start_holdingold;
wire [35:0] with_uart_1_m_dec_1_q_int;
reg signed [30:0] with_uart_1_m_dec_1_bq_int;
reg [29:0] with_uart_1_m_dec_1_increment;
wire with_uart_1_uart_1_baud;
wire with_uart_1_uart_1_slowbaud;
wire with_uart_1_uart_1_slowbaud_rst;
reg with_uart_1_uart_1_started;
reg [2:0] with_uart_1_uart_1_bauds_held_down;
reg [4:0] with_uart_1_uart_1_bits_received;
reg with_uart_1_uart_1_latch_en;
reg with_uart_1_uart_1_clkdiv_2_clk_new;
reg [7:0] with_uart_1_uart_1_clkdiv_2_counter;
reg with_uart_1_uart_1_clkdiv_3_clk_new;
reg [2:0] with_uart_1_uart_1_clkdiv_3_counter;
wire [7:0] with_uart_1_uart_1_shiftreg_1_par_int;
reg with_uart_1_uart_1_shiftreg_1_clk_int;
reg with_uart_1_bussedram_4_rambus_we;
reg with_uart_1_bussedram_5_rambus_we;
reg with_uart_1_bussedram_6_rambus_we;
reg with_uart_1_bussedram_7_rambus_we;
reg [7:0] with_uart_1_comms_arbiter_0_latch_counter;
reg with_uart_1_comms_arbiter_0_drdy_turnedon;
reg with_uart_1_comms_arbiter_0_drdy_old;
wire [49:0] pts_controller_0_amphenol_int;

reg with_uart_1_biggestblock_l [0:32-1];
reg with_uart_1_m_dec_1_to_subtract [0:9-1];
reg with_uart_1_m_dec_1_to_add [0:9-1];
reg [3:0] with_uart_1_m_dec_1_q_int_l [0:9-1];
reg with_uart_1_uart_1_shiftreg_1_latches [0:8-1];
reg [31:0] with_uart_1_bussedram_4_mem [0:128-1];
reg [31:0] with_uart_1_bussedram_5_mem [0:128-1];
reg [31:0] with_uart_1_bussedram_6_mem [0:128-1];
reg [31:0] with_uart_1_bussedram_7_mem [0:128-1];
wire pts_controller_0_amphenol_l [0:50-1];


assign with_uart_1_biggestblock[31] = with_uart_1_biggestblock_l[31];
assign with_uart_1_biggestblock[30] = with_uart_1_biggestblock_l[30];
assign with_uart_1_biggestblock[29] = with_uart_1_biggestblock_l[29];
assign with_uart_1_biggestblock[28] = with_uart_1_biggestblock_l[28];
assign with_uart_1_biggestblock[27] = with_uart_1_biggestblock_l[27];
assign with_uart_1_biggestblock[26] = with_uart_1_biggestblock_l[26];
assign with_uart_1_biggestblock[25] = with_uart_1_biggestblock_l[25];
assign with_uart_1_biggestblock[24] = with_uart_1_biggestblock_l[24];
assign with_uart_1_biggestblock[23] = with_uart_1_biggestblock_l[23];
assign with_uart_1_biggestblock[22] = with_uart_1_biggestblock_l[22];
assign with_uart_1_biggestblock[21] = with_uart_1_biggestblock_l[21];
assign with_uart_1_biggestblock[20] = with_uart_1_biggestblock_l[20];
assign with_uart_1_biggestblock[19] = with_uart_1_biggestblock_l[19];
assign with_uart_1_biggestblock[18] = with_uart_1_biggestblock_l[18];
assign with_uart_1_biggestblock[17] = with_uart_1_biggestblock_l[17];
assign with_uart_1_biggestblock[16] = with_uart_1_biggestblock_l[16];
assign with_uart_1_biggestblock[15] = with_uart_1_biggestblock_l[15];
assign with_uart_1_biggestblock[14] = with_uart_1_biggestblock_l[14];
assign with_uart_1_biggestblock[13] = with_uart_1_biggestblock_l[13];
assign with_uart_1_biggestblock[12] = with_uart_1_biggestblock_l[12];
assign with_uart_1_biggestblock[11] = with_uart_1_biggestblock_l[11];
assign with_uart_1_biggestblock[10] = with_uart_1_biggestblock_l[10];
assign with_uart_1_biggestblock[9] = with_uart_1_biggestblock_l[9];
assign with_uart_1_biggestblock[8] = with_uart_1_biggestblock_l[8];
assign with_uart_1_biggestblock[7] = with_uart_1_biggestblock_l[7];
assign with_uart_1_biggestblock[6] = with_uart_1_biggestblock_l[6];
assign with_uart_1_biggestblock[5] = with_uart_1_biggestblock_l[5];
assign with_uart_1_biggestblock[4] = with_uart_1_biggestblock_l[4];
assign with_uart_1_biggestblock[3] = with_uart_1_biggestblock_l[3];
assign with_uart_1_biggestblock[2] = with_uart_1_biggestblock_l[2];
assign with_uart_1_biggestblock[1] = with_uart_1_biggestblock_l[1];
assign with_uart_1_biggestblock[0] = with_uart_1_biggestblock_l[0];
assign with_uart_1_m_dec_1_q_int[36-1:32] = with_uart_1_m_dec_1_q_int_l[8];
assign with_uart_1_m_dec_1_q_int[32-1:28] = with_uart_1_m_dec_1_q_int_l[7];
assign with_uart_1_m_dec_1_q_int[28-1:24] = with_uart_1_m_dec_1_q_int_l[6];
assign with_uart_1_m_dec_1_q_int[24-1:20] = with_uart_1_m_dec_1_q_int_l[5];
assign with_uart_1_m_dec_1_q_int[20-1:16] = with_uart_1_m_dec_1_q_int_l[4];
assign with_uart_1_m_dec_1_q_int[16-1:12] = with_uart_1_m_dec_1_q_int_l[3];
assign with_uart_1_m_dec_1_q_int[12-1:8] = with_uart_1_m_dec_1_q_int_l[2];
assign with_uart_1_m_dec_1_q_int[8-1:4] = with_uart_1_m_dec_1_q_int_l[1];
assign with_uart_1_m_dec_1_q_int[4-1:0] = with_uart_1_m_dec_1_q_int_l[0];
assign with_uart_1_uart_1_shiftreg_1_par_int[7] = with_uart_1_uart_1_shiftreg_1_latches[0];
assign with_uart_1_uart_1_shiftreg_1_par_int[6] = with_uart_1_uart_1_shiftreg_1_latches[1];
assign with_uart_1_uart_1_shiftreg_1_par_int[5] = with_uart_1_uart_1_shiftreg_1_latches[2];
assign with_uart_1_uart_1_shiftreg_1_par_int[4] = with_uart_1_uart_1_shiftreg_1_latches[3];
assign with_uart_1_uart_1_shiftreg_1_par_int[3] = with_uart_1_uart_1_shiftreg_1_latches[4];
assign with_uart_1_uart_1_shiftreg_1_par_int[2] = with_uart_1_uart_1_shiftreg_1_latches[5];
assign with_uart_1_uart_1_shiftreg_1_par_int[1] = with_uart_1_uart_1_shiftreg_1_latches[6];
assign with_uart_1_uart_1_shiftreg_1_par_int[0] = with_uart_1_uart_1_shiftreg_1_latches[7];
assign pts_controller_0_amphenol_int[49] = pts_controller_0_amphenol_l[49];
assign pts_controller_0_amphenol_int[48] = pts_controller_0_amphenol_l[48];
assign pts_controller_0_amphenol_int[47] = pts_controller_0_amphenol_l[47];
assign pts_controller_0_amphenol_int[46] = pts_controller_0_amphenol_l[46];
assign pts_controller_0_amphenol_int[45] = pts_controller_0_amphenol_l[45];
assign pts_controller_0_amphenol_int[44] = pts_controller_0_amphenol_l[44];
assign pts_controller_0_amphenol_int[43] = pts_controller_0_amphenol_l[43];
assign pts_controller_0_amphenol_int[42] = pts_controller_0_amphenol_l[42];
assign pts_controller_0_amphenol_int[41] = pts_controller_0_amphenol_l[41];
assign pts_controller_0_amphenol_int[40] = pts_controller_0_amphenol_l[40];
assign pts_controller_0_amphenol_int[39] = pts_controller_0_amphenol_l[39];
assign pts_controller_0_amphenol_int[38] = pts_controller_0_amphenol_l[38];
assign pts_controller_0_amphenol_int[37] = pts_controller_0_amphenol_l[37];
assign pts_controller_0_amphenol_int[36] = pts_controller_0_amphenol_l[36];
assign pts_controller_0_amphenol_int[35] = pts_controller_0_amphenol_l[35];
assign pts_controller_0_amphenol_int[34] = pts_controller_0_amphenol_l[34];
assign pts_controller_0_amphenol_int[33] = pts_controller_0_amphenol_l[33];
assign pts_controller_0_amphenol_int[32] = pts_controller_0_amphenol_l[32];
assign pts_controller_0_amphenol_int[31] = pts_controller_0_amphenol_l[31];
assign pts_controller_0_amphenol_int[30] = pts_controller_0_amphenol_l[30];
assign pts_controller_0_amphenol_int[29] = pts_controller_0_amphenol_l[29];
assign pts_controller_0_amphenol_int[28] = pts_controller_0_amphenol_l[28];
assign pts_controller_0_amphenol_int[27] = pts_controller_0_amphenol_l[27];
assign pts_controller_0_amphenol_int[26] = pts_controller_0_amphenol_l[26];
assign pts_controller_0_amphenol_int[25] = pts_controller_0_amphenol_l[25];
assign pts_controller_0_amphenol_int[24] = pts_controller_0_amphenol_l[24];
assign pts_controller_0_amphenol_int[23] = pts_controller_0_amphenol_l[23];
assign pts_controller_0_amphenol_int[22] = pts_controller_0_amphenol_l[22];
assign pts_controller_0_amphenol_int[21] = pts_controller_0_amphenol_l[21];
assign pts_controller_0_amphenol_int[20] = pts_controller_0_amphenol_l[20];
assign pts_controller_0_amphenol_int[19] = pts_controller_0_amphenol_l[19];
assign pts_controller_0_amphenol_int[18] = pts_controller_0_amphenol_l[18];
assign pts_controller_0_amphenol_int[17] = pts_controller_0_amphenol_l[17];
assign pts_controller_0_amphenol_int[16] = pts_controller_0_amphenol_l[16];
assign pts_controller_0_amphenol_int[15] = pts_controller_0_amphenol_l[15];
assign pts_controller_0_amphenol_int[14] = pts_controller_0_amphenol_l[14];
assign pts_controller_0_amphenol_int[13] = pts_controller_0_amphenol_l[13];
assign pts_controller_0_amphenol_int[12] = pts_controller_0_amphenol_l[12];
assign pts_controller_0_amphenol_int[11] = pts_controller_0_amphenol_l[11];
assign pts_controller_0_amphenol_int[10] = pts_controller_0_amphenol_l[10];
assign pts_controller_0_amphenol_int[9] = pts_controller_0_amphenol_l[9];
assign pts_controller_0_amphenol_int[8] = pts_controller_0_amphenol_l[8];
assign pts_controller_0_amphenol_int[7] = pts_controller_0_amphenol_l[7];
assign pts_controller_0_amphenol_int[6] = pts_controller_0_amphenol_l[6];
assign pts_controller_0_amphenol_int[5] = pts_controller_0_amphenol_l[5];
assign pts_controller_0_amphenol_int[4] = pts_controller_0_amphenol_l[4];
assign pts_controller_0_amphenol_int[3] = pts_controller_0_amphenol_l[3];
assign pts_controller_0_amphenol_int[2] = pts_controller_0_amphenol_l[2];
assign pts_controller_0_amphenol_int[1] = pts_controller_0_amphenol_l[1];
assign pts_controller_0_amphenol_int[0] = pts_controller_0_amphenol_l[0];


always @(posedge with_uart_1_start) begin: TOP_WITH_UART_1_M_MANAGER_1_LATCHER
    if (with_uart_1_ready) begin
        with_uart_1_m_manager_1_set_freq_latch <= with_uart_1_set_freq;
        with_uart_1_m_manager_1_set_step_f_latch <= with_uart_1_freq_step;
        with_uart_1_m_manager_1_set_step_t_latch <= with_uart_1_time_step;
        with_uart_1_m_manager_1_set_wait_latch <= with_uart_1_hold_time;
    end
end

// Our beloved finite state machine! For controlling the frequency stepping of the PTS.
// It drives m_dec, which is a special counter that has both a binary output, and hexadecimal
// output (which is what the PTS needs. It steps through the frequency schedule.
always @(with_uart_1_m_manager_1_state, clk, with_uart_1_start, with_uart_1_m_manager_1_quit_turnedon, with_uart_1_m_manager_1_dec_clk_int, with_uart_1_m_manager_1_add_o_int, with_uart_1_m_manager_1_sub_o_int, with_uart_1_m_manager_1_start_holding_turnedon) begin: TOP_WITH_UART_1_M_MANAGER_1_FSM
    if (((with_uart_1_m_manager_1_state == 2'b00) && (with_uart_1_start == 1))) begin
        with_uart_1_dec_clk <= 0;
        with_uart_1_add <= 0;
        with_uart_1_sub <= 0;
        with_uart_1_m_manager_1_frequency_controller_en <= 1'b0;
        with_uart_1_m_manager_1_waiter_en <= 1'b0;
        with_uart_1_ready <= 1'b1;
        with_uart_1_m_manager_1_state <= 2'b01;
    end
    else if (((with_uart_1_m_manager_1_state == 2'b01) && (!with_uart_1_m_manager_1_quit_turnedon))) begin
        with_uart_1_dec_clk <= with_uart_1_m_manager_1_dec_clk_int;
        with_uart_1_add <= with_uart_1_m_manager_1_add_o_int;
        with_uart_1_sub <= with_uart_1_m_manager_1_sub_o_int;
        with_uart_1_m_manager_1_frequency_controller_en <= 1'b1;
        with_uart_1_m_manager_1_waiter_en <= 1'b0;
        with_uart_1_ready <= 1'b0;
    end
    else if (((with_uart_1_m_manager_1_state == 2'b01) && with_uart_1_m_manager_1_quit_turnedon)) begin
        with_uart_1_m_manager_1_state <= 2'b11;
    end
    else begin
        if (with_uart_1_m_manager_1_start_holding_turnedon) begin
            with_uart_1_m_manager_1_state <= 2'b00;
        end
        with_uart_1_dec_clk <= 0;
        with_uart_1_add <= 0;
        with_uart_1_sub <= 0;
        with_uart_1_m_manager_1_frequency_controller_en <= 1'b0;
        with_uart_1_m_manager_1_waiter_en <= 1'b1;
        with_uart_1_ready <= 1'b0;
    end
end


always @(posedge with_uart_1_m_manager_1_freq_controller_clk, posedge with_uart_1_reset) begin: TOP_WITH_UART_1_M_MANAGER_1_FREQUENCY_CONTROLLER
    integer power;
    if (with_uart_1_reset == 1) begin
        with_uart_1_m_manager_1_delta_freq <= 00000000;
        with_uart_1_m_manager_1_quit <= 0;
        with_uart_1_m_manager_1_set_step_f_latch_int <= 00000000;
        with_uart_1_m_manager_1_direction <= 1'b0;
        with_uart_1_m_manager_1_set_freq_latch_int <= 00000000;
        with_uart_1_m_manager_1_dec_clk_en <= 0;
        with_uart_1_incr <= 000;
        with_uart_1_m_manager_1_add_o_int <= 0;
        with_uart_1_m_manager_1_sub_o_int <= 0;
    end
    else begin
        for (power=0; power<9; power=power+1) begin
            if (($signed({1'b0, with_uart_1_m_manager_1_set_step_f_latch}) == power)) begin
                with_uart_1_m_manager_1_delta_freq <= (10 ** power);
            end
        end
        if ((with_uart_1_m_manager_1_curr_freq > with_uart_1_m_manager_1_set_freq_latch)) begin
            with_uart_1_m_manager_1_quit <= 0;
            if ((with_uart_1_m_manager_1_direction == 1'b0)) begin
                if ((($signed({1'b0, with_uart_1_m_manager_1_set_step_f_latch}) + with_uart_1_m_manager_1_set_step_f_latch_int) >= 1)) begin
                    with_uart_1_m_manager_1_set_step_f_latch_int <= (with_uart_1_m_manager_1_set_step_f_latch_int - 1);
                end
                with_uart_1_m_manager_1_direction <= 1'b1;
            end
            else begin
                with_uart_1_m_manager_1_direction <= 1'b1;
            end
        end
        else if ((with_uart_1_m_manager_1_curr_freq < (with_uart_1_m_manager_1_set_freq_latch + with_uart_1_m_manager_1_set_freq_latch_int))) begin
            with_uart_1_m_manager_1_quit <= 0;
            if ((with_uart_1_m_manager_1_direction == 1'b1)) begin
                if ((($signed({1'b0, with_uart_1_m_manager_1_set_step_f_latch}) + with_uart_1_m_manager_1_set_freq_latch_int) >= 1)) begin
                    with_uart_1_m_manager_1_set_freq_latch_int <= (with_uart_1_m_manager_1_set_freq_latch_int - 1);
                end
                with_uart_1_m_manager_1_direction <= 1'b0;
            end
            else begin
                with_uart_1_m_manager_1_direction <= 1'b0;
            end
        end
        else begin
            with_uart_1_m_manager_1_dec_clk_en <= 0;
            with_uart_1_incr <= 0;
            with_uart_1_m_manager_1_add_o_int <= 0;
            with_uart_1_m_manager_1_sub_o_int <= 0;
            with_uart_1_m_manager_1_quit <= 1;
        end
        if ((with_uart_1_m_manager_1_direction == 1'b0)) begin
            with_uart_1_m_manager_1_add_o_int <= 1;
            with_uart_1_m_manager_1_sub_o_int <= 0;
            with_uart_1_incr <= ($signed({1'b0, with_uart_1_m_manager_1_set_step_f_latch}) + with_uart_1_m_manager_1_set_freq_latch_int);
            with_uart_1_m_manager_1_dec_clk_en <= 1;
        end
        else begin
            with_uart_1_m_manager_1_add_o_int <= 0;
            with_uart_1_m_manager_1_sub_o_int <= 1;
            with_uart_1_incr <= ($signed({1'b0, with_uart_1_m_manager_1_set_step_f_latch}) + with_uart_1_m_manager_1_set_freq_latch_int);
            with_uart_1_m_manager_1_dec_clk_en <= 1;
        end
    end
end


always @(posedge with_uart_1_m_manager_1_waiter_clk, posedge with_uart_1_reset) begin: TOP_WITH_UART_1_M_MANAGER_1_HOLDER
    if (with_uart_1_reset == 1) begin
        with_uart_1_m_manager_1_start_holding <= 0;
        with_uart_1_m_manager_1_set_wait_latch_int <= 00000000;
    end
    else begin
        if ((($signed({1'b0, with_uart_1_m_manager_1_set_wait_latch}) + with_uart_1_m_manager_1_set_wait_latch_int) == 0)) begin
            with_uart_1_m_manager_1_start_holding <= 1;
        end
        else begin
            with_uart_1_m_manager_1_start_holding <= 0;
            with_uart_1_m_manager_1_set_wait_latch_int <= (with_uart_1_m_manager_1_set_wait_latch_int - 1);
        end
    end
end



assign with_uart_1_m_manager_1_freq_controller_clk = (with_uart_1_m_manager_1_frequency_controller_en && clk);
assign with_uart_1_m_manager_1_waiter_clk = (with_uart_1_m_manager_1_waiter_en && clk);
assign with_uart_1_m_manager_1_dec_clk_int = (with_uart_1_m_manager_1_dec_clk_en && clk);
assign with_uart_1_m_manager_1_curr_freq = with_uart_1_curr_freq;


always @(posedge clk, posedge with_uart_1_reset) begin: TOP_WITH_UART_1_M_MANAGER_1_QUIT_MONITOR
    if (with_uart_1_reset == 1) begin
        with_uart_1_m_manager_1_quitold <= 0;
        with_uart_1_m_manager_1_start_holdingold <= 0;
        with_uart_1_m_manager_1_quit_turnedon <= 0;
        with_uart_1_m_manager_1_start_holding_turnedon <= 0;
    end
    else begin
        with_uart_1_m_manager_1_quitold <= with_uart_1_m_manager_1_quit;
        with_uart_1_m_manager_1_start_holdingold <= with_uart_1_m_manager_1_start_holdingold;
        if (((with_uart_1_m_manager_1_quitold == 0) && (with_uart_1_m_manager_1_quit == 1))) begin
            with_uart_1_m_manager_1_quit_turnedon <= 1;
        end
        else begin
            with_uart_1_m_manager_1_quit_turnedon <= 0;
        end
        if (((with_uart_1_m_manager_1_start_holdingold == 0) && (with_uart_1_m_manager_1_start_holding == 1))) begin
            with_uart_1_m_manager_1_start_holding_turnedon <= 1;
        end
        else begin
            with_uart_1_m_manager_1_start_holding_turnedon <= 0;
        end
    end
end


always @(posedge with_uart_1_dec_clk) begin: TOP_WITH_UART_1_M_DEC_1_WIRING
    hex_freq <= with_uart_1_m_dec_1_q_int;
    with_uart_1_curr_freq <= with_uart_1_m_dec_1_bq_int;
end

// This is the HEXADECIMAL counter.
// It adds or subtracts only if (add xor sub) is True, to allow for the carry logic
// a new bit of logic is required, namely addlogic, and sublogic. They give out 
// lists of vectors (or integer masks). These are used in the logic below. And work 
// out most of the stuff. One extra if statement is needed to increment the desired 
// byte.
always @(negedge with_uart_1_dec_clk, posedge with_uart_1_reset) begin: TOP_WITH_UART_1_M_DEC_1_HEX_COUNTER
    integer digit;
    if (with_uart_1_reset == 1) begin
        with_uart_1_m_dec_1_q_int_l[0] <= 0;
        with_uart_1_m_dec_1_q_int_l[1] <= 0;
        with_uart_1_m_dec_1_q_int_l[2] <= 0;
        with_uart_1_m_dec_1_q_int_l[3] <= 0;
        with_uart_1_m_dec_1_q_int_l[4] <= 0;
        with_uart_1_m_dec_1_q_int_l[5] <= 0;
        with_uart_1_m_dec_1_q_int_l[6] <= 0;
        with_uart_1_m_dec_1_q_int_l[7] <= 0;
        with_uart_1_m_dec_1_q_int_l[8] <= 0;
    end
    else begin
        if (((with_uart_1_add == 1'b1) && (!with_uart_1_sub))) begin
            for (digit=1; digit<9; digit=digit+1) begin
                if ((digit > $signed({1'b0, with_uart_1_incr}))) begin
                    if (with_uart_1_m_dec_1_to_add[digit]) begin
                        if ((with_uart_1_m_dec_1_q_int_l[digit] != 9)) begin
                            with_uart_1_m_dec_1_q_int_l[digit] <= (with_uart_1_m_dec_1_q_int_l[digit] + 1);
                        end
                        else begin
                            with_uart_1_m_dec_1_q_int_l[digit] <= 0;
                        end
                    end
                    else begin
                        with_uart_1_m_dec_1_q_int_l[digit] <= with_uart_1_m_dec_1_q_int_l[digit];
                    end
                end
                else if ((digit == $signed({1'b0, with_uart_1_incr}))) begin
                    if ((with_uart_1_m_dec_1_q_int_l[with_uart_1_incr] != 9)) begin
                        with_uart_1_m_dec_1_q_int_l[with_uart_1_incr] <= (with_uart_1_m_dec_1_q_int_l[with_uart_1_incr] + 1);
                    end
                    else begin
                        with_uart_1_m_dec_1_q_int_l[with_uart_1_incr] <= 0;
                    end
                end
            end
        end
        else if (((with_uart_1_sub == 1'b1) && (!with_uart_1_add))) begin
            for (digit=1; digit<9; digit=digit+1) begin
                if ((digit > $signed({1'b0, with_uart_1_incr}))) begin
                    if (with_uart_1_m_dec_1_to_subtract[digit]) begin
                        if ((with_uart_1_m_dec_1_q_int_l[digit] != 0)) begin
                            with_uart_1_m_dec_1_q_int_l[digit] <= (with_uart_1_m_dec_1_q_int_l[digit] - 1);
                        end
                        else begin
                            with_uart_1_m_dec_1_q_int_l[digit] <= 9;
                        end
                    end
                    else begin
                        with_uart_1_m_dec_1_q_int_l[digit] <= with_uart_1_m_dec_1_q_int_l[digit];
                    end
                end
                else if ((digit == $signed({1'b0, with_uart_1_incr}))) begin
                    if ((with_uart_1_m_dec_1_q_int_l[with_uart_1_incr] != 0)) begin
                        with_uart_1_m_dec_1_q_int_l[with_uart_1_incr] <= (with_uart_1_m_dec_1_q_int_l[with_uart_1_incr] - 1);
                    end
                    else begin
                        with_uart_1_m_dec_1_q_int_l[with_uart_1_incr] <= 9;
                    end
                end
            end
        end
        else begin
            for (digit=0; digit<9; digit=digit+1) begin
                with_uart_1_m_dec_1_q_int_l[digit] <= with_uart_1_m_dec_1_q_int_l[digit];
            end
        end
    end
end

// This module determines whether or not to add certain bits,
// in the case of carry over. First we make sure we don't add all
// the bits lower than increment, then we set the increment bit to add,
// and lastly we perform the logic neccessary to determine if bits greater
// than incr need to be added
// 
// It's sensitivity list is long, this is neccessary as to allow the logic 
// to update to_add when any part of to_add changes, as is the case
// when performing carry logic.
always @(with_uart_1_incr, with_uart_1_m_dec_1_q_int, with_uart_1_m_dec_1_to_add[0], with_uart_1_m_dec_1_to_add[1], with_uart_1_m_dec_1_to_add[2], with_uart_1_m_dec_1_to_add[3], with_uart_1_m_dec_1_to_add[4], with_uart_1_m_dec_1_to_add[5], with_uart_1_m_dec_1_to_add[6], with_uart_1_m_dec_1_to_add[7], with_uart_1_m_dec_1_to_add[8]) begin: TOP_WITH_UART_1_M_DEC_1_ADDLOGIC
    integer digit;
    for (digit=0; digit<9; digit=digit+1) begin
        if ((digit < $signed({1'b0, with_uart_1_incr}))) begin
            with_uart_1_m_dec_1_to_add[digit] <= 0;
        end
        else if ((digit == $signed({1'b0, with_uart_1_incr}))) begin
            with_uart_1_m_dec_1_to_add[with_uart_1_incr] <= 1;
        end
        else begin
            with_uart_1_m_dec_1_to_add[digit] <= ((with_uart_1_m_dec_1_q_int_l[(digit - 1)] == 9) && with_uart_1_m_dec_1_to_add[(digit - 1)]);
        end
    end
end

// This module determines whether or not to subtract certain bits,
// in the case of carry over. First we make sure we don't subtract all
// the bits lower than increment, then we set the increment bit to subtract,
// and lastly we perform the logic neccessary to determine if bits greater
// than incr need to be subtracted.
// 
// It's sensitivity list is long, this is neccessary as to allow the logic 
// to update to_subtract when any part of to_subtract changes, as is the case
// when performing carry logic.
always @(with_uart_1_incr, with_uart_1_m_dec_1_q_int, with_uart_1_m_dec_1_to_subtract[0], with_uart_1_m_dec_1_to_subtract[1], with_uart_1_m_dec_1_to_subtract[2], with_uart_1_m_dec_1_to_subtract[3], with_uart_1_m_dec_1_to_subtract[4], with_uart_1_m_dec_1_to_subtract[5], with_uart_1_m_dec_1_to_subtract[6], with_uart_1_m_dec_1_to_subtract[7], with_uart_1_m_dec_1_to_subtract[8]) begin: TOP_WITH_UART_1_M_DEC_1_SUBLOGIC
    integer digit;
    for (digit=0; digit<9; digit=digit+1) begin
        if ((digit < $signed({1'b0, with_uart_1_incr}))) begin
            with_uart_1_m_dec_1_to_subtract[digit] <= 0;
        end
        else if ((digit == $signed({1'b0, with_uart_1_incr}))) begin
            with_uart_1_m_dec_1_to_subtract[with_uart_1_incr] <= 1;
        end
        else begin
            with_uart_1_m_dec_1_to_subtract[digit] <= ((with_uart_1_m_dec_1_q_int_l[(digit - 1)] == 0) && with_uart_1_m_dec_1_to_subtract[(digit - 1)]);
        end
    end
end

// Here is the binary counter for bq. 
// It's value should synchronously be the same
// as q. This logic should be simple, and it is,
// but it freaks out when you subtract too far. Be warned!
always @(negedge with_uart_1_dec_clk, posedge with_uart_1_reset) begin: TOP_WITH_UART_1_M_DEC_1_BIN_COUNTER
    if (with_uart_1_reset == 1) begin
        with_uart_1_m_dec_1_bq_int <= 00000000;
    end
    else begin
        if ((with_uart_1_add && (!with_uart_1_sub))) begin
            with_uart_1_m_dec_1_bq_int <= (with_uart_1_m_dec_1_bq_int + $signed({1'b0, with_uart_1_m_dec_1_increment}));
        end
        else if ((with_uart_1_sub && (!with_uart_1_add))) begin
            with_uart_1_m_dec_1_bq_int <= (with_uart_1_m_dec_1_bq_int - $signed({1'b0, with_uart_1_m_dec_1_increment}));
        end
        else begin
            with_uart_1_m_dec_1_bq_int <= with_uart_1_m_dec_1_bq_int;
        end
    end
end


always @(with_uart_1_incr) begin: TOP_WITH_UART_1_M_DEC_1_ROM_1_READ
    case (with_uart_1_incr)
        0: with_uart_1_m_dec_1_increment = 1;
        1: with_uart_1_m_dec_1_increment = 10;
        2: with_uart_1_m_dec_1_increment = 100;
        3: with_uart_1_m_dec_1_increment = 1000;
        4: with_uart_1_m_dec_1_increment = 10000;
        5: with_uart_1_m_dec_1_increment = 100000;
        6: with_uart_1_m_dec_1_increment = 1000000;
        7: with_uart_1_m_dec_1_increment = 10000000;
        default: with_uart_1_m_dec_1_increment = 100000000;
    endcase
end


always @(posedge with_uart_1_uart_1_baud) begin: TOP_WITH_UART_1_UART_1_CHECKFORENDBITS
    if ((!with_uart_1_uart_1_started)) begin
        if ((fpga_rx == 0)) begin
            if ((with_uart_1_uart_1_bauds_held_down != 4)) begin
                with_uart_1_uart_1_bauds_held_down <= (with_uart_1_uart_1_bauds_held_down + 1);
                with_uart_1_uart_1_latch_en <= 0;
            end
            else begin
                with_uart_1_uart_1_bauds_held_down <= 0;
                with_uart_1_uart_1_started <= 1;
                with_uart_1_uart_1_latch_en <= 1;
            end
        end
        else begin
            with_uart_1_uart_1_latch_en <= 0;
            with_uart_1_uart_1_bauds_held_down <= 0;
        end
    end
    else begin
        if ((with_uart_1_uart_1_bits_received == 8)) begin
            with_uart_1_uart_1_latch_en <= 0;
        end
        else begin
            with_uart_1_uart_1_latch_en <= 1;
        end
        if (((fpga_rx == 1) && (with_uart_1_uart_1_bits_received == 8))) begin
            if (($signed({1'b0, with_uart_1_uart_1_bauds_held_down}) != (4 + ((1 - 1) * 8)))) begin
                with_uart_1_uart_1_bauds_held_down <= (with_uart_1_uart_1_bauds_held_down + 1);
            end
            else begin
                with_uart_1_uart_1_bauds_held_down <= 0;
                with_uart_1_uart_1_started <= 0;
            end
        end
        else if ((with_uart_1_uart_1_bits_received == 8)) begin
            with_uart_1_uart_1_bauds_held_down <= 0;
        end
    end
end



assign with_uart_1_uart_1_slowbaud_rst = (!with_uart_1_uart_1_started);
assign with_uart_1_drdy = (!with_uart_1_uart_1_started);


always @(posedge with_uart_1_uart_1_slowbaud, posedge with_uart_1_uart_1_slowbaud_rst) begin: TOP_WITH_UART_1_UART_1_COUNTTHEMBITS
    if (with_uart_1_uart_1_slowbaud_rst == 1) begin
        with_uart_1_uart_1_bits_received <= 00;
    end
    else begin
        if (with_uart_1_uart_1_latch_en) begin
            with_uart_1_uart_1_bits_received <= (with_uart_1_uart_1_bits_received + 1);
        end
    end
end


always @(posedge clk) begin: TOP_WITH_UART_1_UART_1_CLKDIV_2_CLOCKDIVIDER
    if ((($signed({1'b0, with_uart_1_uart_1_clkdiv_2_counter}) == (156 - 1)) || (with_uart_1_uart_1_clkdiv_2_counter == (156 / 2)))) begin
        with_uart_1_uart_1_clkdiv_2_clk_new <= (!with_uart_1_uart_1_clkdiv_2_clk_new);
    end
    if (($signed({1'b0, with_uart_1_uart_1_clkdiv_2_counter}) == (156 - 1))) begin
        with_uart_1_uart_1_clkdiv_2_counter <= 0;
    end
    else begin
        with_uart_1_uart_1_clkdiv_2_counter <= (with_uart_1_uart_1_clkdiv_2_counter + 1);
    end
end



assign with_uart_1_uart_1_baud = with_uart_1_uart_1_clkdiv_2_clk_new;


always @(posedge with_uart_1_uart_1_baud, posedge with_uart_1_uart_1_slowbaud_rst) begin: TOP_WITH_UART_1_UART_1_CLKDIV_3_CLOCKDIVIDER
    if (with_uart_1_uart_1_slowbaud_rst == 1) begin
        with_uart_1_uart_1_clkdiv_3_clk_new <= 0;
        with_uart_1_uart_1_clkdiv_3_counter <= 0;
    end
    else begin
        if ((($signed({1'b0, with_uart_1_uart_1_clkdiv_3_counter}) == (8 - 1)) || (with_uart_1_uart_1_clkdiv_3_counter == (8 / 2)))) begin
            with_uart_1_uart_1_clkdiv_3_clk_new <= (!with_uart_1_uart_1_clkdiv_3_clk_new);
        end
        if (($signed({1'b0, with_uart_1_uart_1_clkdiv_3_counter}) == (8 - 1))) begin
            with_uart_1_uart_1_clkdiv_3_counter <= 0;
        end
        else begin
            with_uart_1_uart_1_clkdiv_3_counter <= (with_uart_1_uart_1_clkdiv_3_counter + 1);
        end
    end
end



assign with_uart_1_uart_1_slowbaud = with_uart_1_uart_1_clkdiv_3_clk_new;


always @(with_uart_1_uart_1_slowbaud, with_uart_1_uart_1_latch_en) begin: TOP_WITH_UART_1_UART_1_SHIFTREG_1_WIRING
    integer i;
    for (i=0; i<8; i=i+1) begin
        with_uart_1_uart_1_shiftreg_1_clk_int <= (with_uart_1_uart_1_slowbaud && with_uart_1_uart_1_latch_en);
    end
end


always @(posedge with_uart_1_uart_1_shiftreg_1_clk_int) begin: TOP_WITH_UART_1_UART_1_SHIFTREG_1_LATCHER
    integer i;
    reg [0-1:0] loadval;
    if ((1'b0 == 1'b0)) begin
        with_uart_1_uart_1_shiftreg_1_latches[0] <= fpga_rx;
        for (i=1; i<8; i=i+1) begin
            with_uart_1_uart_1_shiftreg_1_latches[i] <= with_uart_1_uart_1_shiftreg_1_latches[(i - 1)];
        end
    end
    else begin
        for (i=0; i<8; i=i+1) begin
            with_uart_1_uart_1_shiftreg_1_latches[i] <= loadval[i];
        end
    end
end



assign with_uart_1_rx_data = with_uart_1_uart_1_shiftreg_1_par_int;


always @(posedge with_uart_1_freq_rambus_clk) begin: TOP_WITH_UART_1_BUSSEDRAM_4_WRITE
    if (with_uart_1_bussedram_4_rambus_we) begin
        with_uart_1_bussedram_4_mem[with_uart_1_freq_rambus_addr_renamed0] <= with_uart_1_freq_rambus_din;
    end
end



assign with_uart_1_freq_rambus_dout = with_uart_1_bussedram_4_mem[with_uart_1_freq_rambus_addr_renamed0];


always @(posedge with_uart_1_fstep_rambus_clk) begin: TOP_WITH_UART_1_BUSSEDRAM_5_WRITE
    if (with_uart_1_bussedram_5_rambus_we) begin
        with_uart_1_bussedram_5_mem[with_uart_1_fstep_rambus_addr_renamed0] <= with_uart_1_fstep_rambus_din;
    end
end



assign with_uart_1_fstep_rambus_dout = with_uart_1_bussedram_5_mem[with_uart_1_fstep_rambus_addr_renamed0];


always @(posedge with_uart_1_tstep_rambus_clk) begin: TOP_WITH_UART_1_BUSSEDRAM_6_WRITE
    if (with_uart_1_bussedram_6_rambus_we) begin
        with_uart_1_bussedram_6_mem[with_uart_1_tstep_rambus_addr_renamed0] <= with_uart_1_tstep_rambus_din;
    end
end



assign with_uart_1_tstep_rambus_dout = with_uart_1_bussedram_6_mem[with_uart_1_tstep_rambus_addr_renamed0];


always @(posedge with_uart_1_hold_rambus_clk) begin: TOP_WITH_UART_1_BUSSEDRAM_7_WRITE
    if (with_uart_1_bussedram_7_rambus_we) begin
        with_uart_1_bussedram_7_mem[with_uart_1_hold_rambus_addr_renamed0] <= with_uart_1_hold_rambus_din;
    end
end



assign with_uart_1_hold_rambus_dout = with_uart_1_bussedram_7_mem[with_uart_1_hold_rambus_addr_renamed0];


always @(posedge clk, posedge with_uart_1_reset) begin: TOP_WITH_UART_1_SCHEDULE_ARBITER
    if (with_uart_1_reset == 1) begin
        with_uart_1_start <= 0;
        with_uart_1_sched_index <= 00;
        with_uart_1_done <= 0;
    end
    else begin
        if ((with_uart_1_ready == 1'b1)) begin
            with_uart_1_start <= ((1 && (!with_uart_1_done)) && trigger);
            if (($signed({1'b0, with_uart_1_sched_index}) < ($signed({1'b0, with_uart_1_sched_len}) - 1))) begin
                with_uart_1_sched_index <= (with_uart_1_sched_index + 1);
            end
            else begin
                with_uart_1_done <= 1;
            end
        end
        else begin
            with_uart_1_start <= 0;
        end
    end
end

// This fsm latches (just after) the dataready positive edge
// signal. The data is guaranteed to be ready then.
always @(posedge clk, posedge with_uart_1_reset) begin: TOP_WITH_UART_1_COMMS_ARBITER_0_FSM
    integer i;
    if (with_uart_1_reset == 1) begin
        with_uart_1_bussedram_4_rambus_we <= 0;
        with_uart_1_bussedram_5_rambus_we <= 0;
        with_uart_1_bussedram_6_rambus_we <= 0;
        with_uart_1_bussedram_7_rambus_we <= 0;
        with_uart_1_whichram <= 00;
        with_uart_1_state <= 2'b00;
        with_uart_1_comms_arbiter_0_latch_counter <= 00;
        with_uart_1_biggestblock_l[0] <= 0;
        with_uart_1_biggestblock_l[1] <= 0;
        with_uart_1_biggestblock_l[2] <= 0;
        with_uart_1_biggestblock_l[3] <= 0;
        with_uart_1_biggestblock_l[4] <= 0;
        with_uart_1_biggestblock_l[5] <= 0;
        with_uart_1_biggestblock_l[6] <= 0;
        with_uart_1_biggestblock_l[7] <= 0;
        with_uart_1_biggestblock_l[8] <= 0;
        with_uart_1_biggestblock_l[9] <= 0;
        with_uart_1_biggestblock_l[10] <= 0;
        with_uart_1_biggestblock_l[11] <= 0;
        with_uart_1_biggestblock_l[12] <= 0;
        with_uart_1_biggestblock_l[13] <= 0;
        with_uart_1_biggestblock_l[14] <= 0;
        with_uart_1_biggestblock_l[15] <= 0;
        with_uart_1_biggestblock_l[16] <= 0;
        with_uart_1_biggestblock_l[17] <= 0;
        with_uart_1_biggestblock_l[18] <= 0;
        with_uart_1_biggestblock_l[19] <= 0;
        with_uart_1_biggestblock_l[20] <= 0;
        with_uart_1_biggestblock_l[21] <= 0;
        with_uart_1_biggestblock_l[22] <= 0;
        with_uart_1_biggestblock_l[23] <= 0;
        with_uart_1_biggestblock_l[24] <= 0;
        with_uart_1_biggestblock_l[25] <= 0;
        with_uart_1_biggestblock_l[26] <= 0;
        with_uart_1_biggestblock_l[27] <= 0;
        with_uart_1_biggestblock_l[28] <= 0;
        with_uart_1_biggestblock_l[29] <= 0;
        with_uart_1_biggestblock_l[30] <= 0;
        with_uart_1_biggestblock_l[31] <= 0;
        with_uart_1_freq_rambus_length <= 00;
        with_uart_1_freq_rambus_addr <= 00;
        with_uart_1_fstep_rambus_length <= 00;
        with_uart_1_fstep_rambus_addr <= 00;
        with_uart_1_tstep_rambus_length <= 00;
        with_uart_1_tstep_rambus_addr <= 00;
        with_uart_1_hold_rambus_length <= 00;
        with_uart_1_hold_rambus_addr <= 00;
        with_uart_1_reset <= 0;
    end
    else begin
        if (((with_uart_1_state == 2'b00) && with_uart_1_comms_arbiter_0_drdy_turnedon)) begin
            with_uart_1_bussedram_4_rambus_we <= 0;
            with_uart_1_bussedram_5_rambus_we <= 0;
            with_uart_1_bussedram_6_rambus_we <= 0;
            with_uart_1_bussedram_7_rambus_we <= 0;
            with_uart_1_whichram <= with_uart_1_rx_data;
            if ((with_uart_1_rx_data != 255)) begin
                with_uart_1_state <= 2'b01;
            end
            else begin
                with_uart_1_state <= 2'b11;
            end
        end
        else if (((with_uart_1_state == 2'b01) && with_uart_1_comms_arbiter_0_drdy_turnedon)) begin
            with_uart_1_comms_arbiter_0_latch_counter <= (with_uart_1_comms_arbiter_0_latch_counter + 1);
            for (i=0; i<8; i=i+1) begin
                with_uart_1_biggestblock_l[(i + (8 * with_uart_1_comms_arbiter_0_latch_counter))] <= with_uart_1_rx_data[i];
            end
            if ((with_uart_1_comms_arbiter_0_latch_counter == 3)) begin
                with_uart_1_comms_arbiter_0_latch_counter <= 0;
                with_uart_1_state <= 2'b10;
            end
        end
        else if ((with_uart_1_state == 2'b10)) begin
            case (with_uart_1_whichram)
                'h0: begin
                    with_uart_1_bussedram_4_rambus_we <= 1;
                    with_uart_1_freq_rambus_length <= (with_uart_1_freq_rambus_length + 1);
                    with_uart_1_freq_rambus_addr <= (with_uart_1_freq_rambus_addr + 1);
                end
                'h1: begin
                    with_uart_1_bussedram_5_rambus_we <= 1;
                    with_uart_1_fstep_rambus_length <= (with_uart_1_fstep_rambus_length + 1);
                    with_uart_1_fstep_rambus_addr <= (with_uart_1_fstep_rambus_addr + 1);
                end
                'h2: begin
                    with_uart_1_bussedram_6_rambus_we <= 1;
                    with_uart_1_tstep_rambus_length <= (with_uart_1_tstep_rambus_length + 1);
                    with_uart_1_tstep_rambus_addr <= (with_uart_1_tstep_rambus_addr + 1);
                end
                'h3: begin
                    with_uart_1_bussedram_7_rambus_we <= 1;
                    with_uart_1_hold_rambus_length <= (with_uart_1_hold_rambus_length + 1);
                    with_uart_1_hold_rambus_addr <= (with_uart_1_hold_rambus_addr + 1);
                end
                default: begin
                    with_uart_1_bussedram_4_rambus_we <= 0;
                    with_uart_1_bussedram_5_rambus_we <= 0;
                    with_uart_1_bussedram_6_rambus_we <= 0;
                    with_uart_1_bussedram_7_rambus_we <= 0;
                end
            endcase
            with_uart_1_state <= 2'b00;
        end
        else begin
            with_uart_1_reset <= 1;
        end
    end
end

// This is a little block for determining whether 
// drdy has transitioned in the last clock cycle.
// It effectively turns the drdy step function into 
// a hat function.
always @(posedge clk, posedge with_uart_1_reset) begin: TOP_WITH_UART_1_COMMS_ARBITER_0_DRDY_MONITOR
    if (with_uart_1_reset == 1) begin
        with_uart_1_comms_arbiter_0_drdy_old <= 0;
        with_uart_1_comms_arbiter_0_drdy_turnedon <= 0;
    end
    else begin
        with_uart_1_comms_arbiter_0_drdy_old <= with_uart_1_drdy;
        if (((with_uart_1_drdy != with_uart_1_comms_arbiter_0_drdy_old) && (with_uart_1_comms_arbiter_0_drdy_old == 0))) begin
            with_uart_1_comms_arbiter_0_drdy_turnedon <= 1;
        end
        else begin
            with_uart_1_comms_arbiter_0_drdy_turnedon <= 0;
        end
    end
end

// Just connect the notclock signal for passing into the RAMs  

assign with_uart_1_notclock = (!clk);

// Some nasty combinatorial logic here to determine
// the schedule length
always @(with_uart_1_freq_rambus_length, with_uart_1_fstep_rambus_length, with_uart_1_tstep_rambus_length, with_uart_1_hold_rambus_length, with_uart_1_drdy) begin: TOP_WITH_UART_1_DETERMINE_SCHED_LEN
    if (((with_uart_1_freq_rambus_length < with_uart_1_fstep_rambus_length) && (with_uart_1_freq_rambus_length < with_uart_1_tstep_rambus_length) && (with_uart_1_freq_rambus_length < with_uart_1_hold_rambus_length))) begin
        with_uart_1_sched_len <= with_uart_1_freq_rambus_length;
    end
    else if (((with_uart_1_tstep_rambus_length < with_uart_1_fstep_rambus_length) && (with_uart_1_tstep_rambus_length < with_uart_1_freq_rambus_length) && (with_uart_1_tstep_rambus_length < with_uart_1_hold_rambus_length))) begin
        with_uart_1_sched_len <= with_uart_1_tstep_rambus_length;
    end
    else if (((with_uart_1_hold_rambus_length < with_uart_1_fstep_rambus_length) && (with_uart_1_hold_rambus_length < with_uart_1_freq_rambus_length) && (with_uart_1_hold_rambus_length < with_uart_1_tstep_rambus_length))) begin
        with_uart_1_sched_len <= with_uart_1_hold_rambus_length;
    end
    else begin
        with_uart_1_sched_len <= with_uart_1_fstep_rambus_length;
    end
end

// Connect basic signals of the RAMS: data in and data_out and clock
always @(posedge clk, posedge with_uart_1_reset) begin: TOP_WITH_UART_1_RAMWIRING
    integer i;
    if (with_uart_1_reset == 1) begin
        with_uart_1_freq_rambus_din <= 00000000;
        with_uart_1_fstep_rambus_din <= 00000000;
        with_uart_1_tstep_rambus_din <= 00000000;
        with_uart_1_hold_rambus_din <= 00000000;
        with_uart_1_set_freq <= 00000000;
        with_uart_1_freq_step <= 00000000;
        with_uart_1_time_step <= 00000000;
        with_uart_1_hold_time <= 00000000;
        with_uart_1_freq_rambus_clk <= 0;
        with_uart_1_fstep_rambus_clk <= 0;
        with_uart_1_tstep_rambus_clk <= 0;
        with_uart_1_hold_rambus_clk <= 0;
        with_uart_1_freq_rambus_addr_renamed0 <= 00;
        with_uart_1_fstep_rambus_addr_renamed0 <= 00;
        with_uart_1_tstep_rambus_addr_renamed0 <= 00;
        with_uart_1_hold_rambus_addr_renamed0 <= 00;
    end
    else begin
        for (i=0; i<32; i=i+1) begin
            with_uart_1_freq_rambus_din <= with_uart_1_biggestblock[32-1:0];
            with_uart_1_fstep_rambus_din <= with_uart_1_biggestblock[32-1:0];
            with_uart_1_tstep_rambus_din <= with_uart_1_biggestblock[32-1:0];
            with_uart_1_hold_rambus_din <= with_uart_1_biggestblock[32-1:0];
        end
        with_uart_1_set_freq <= with_uart_1_freq_rambus_dout;
        with_uart_1_freq_step <= with_uart_1_fstep_rambus_dout;
        with_uart_1_time_step <= with_uart_1_tstep_rambus_dout;
        with_uart_1_hold_time <= with_uart_1_hold_rambus_dout;
        with_uart_1_freq_rambus_clk <= with_uart_1_notclock;
        with_uart_1_fstep_rambus_clk <= with_uart_1_notclock;
        with_uart_1_tstep_rambus_clk <= with_uart_1_notclock;
        with_uart_1_hold_rambus_clk <= with_uart_1_notclock;
        if ((with_uart_1_state == 2'b00)) begin
            with_uart_1_freq_rambus_addr_renamed0 <= with_uart_1_sched_index;
            with_uart_1_fstep_rambus_addr_renamed0 <= with_uart_1_sched_index;
            with_uart_1_tstep_rambus_addr_renamed0 <= with_uart_1_sched_index;
            with_uart_1_hold_rambus_addr_renamed0 <= with_uart_1_sched_index;
        end
        else begin
            with_uart_1_freq_rambus_addr_renamed0 <= with_uart_1_freq_rambus_addr;
            with_uart_1_fstep_rambus_addr_renamed0 <= with_uart_1_fstep_rambus_addr;
            with_uart_1_tstep_rambus_addr_renamed0 <= with_uart_1_tstep_rambus_addr;
            with_uart_1_hold_rambus_addr_renamed0 <= with_uart_1_hold_rambus_addr;
        end
    end
end



assign amphenol = pts_controller_0_amphenol_int;
assign pts_controller_0_amphenol_l[49] = 0;
assign pts_controller_0_amphenol_l[48] = 1;
assign pts_controller_0_amphenol_l[41] = (!1'b1);
assign pts_controller_0_amphenol_l[20] = 0;
assign pts_controller_0_amphenol_l[21] = 0;
assign pts_controller_0_amphenol_l[22] = 1;
assign pts_controller_0_amphenol_l[23] = 1;
assign pts_controller_0_amphenol_l[24] = 1;
assign pts_controller_0_amphenol_l[45] = 1;
assign pts_controller_0_amphenol_l[46] = 1;
assign pts_controller_0_amphenol_l[43] = (!hex_freq[33]);
assign pts_controller_0_amphenol_l[42] = (!hex_freq[32]);
assign pts_controller_0_amphenol_l[40] = (!hex_freq[31]);
assign pts_controller_0_amphenol_l[39] = (!hex_freq[30]);
assign pts_controller_0_amphenol_l[15] = (!hex_freq[29]);
assign pts_controller_0_amphenol_l[14] = (!hex_freq[28]);
assign pts_controller_0_amphenol_l[19] = (!hex_freq[27]);
assign pts_controller_0_amphenol_l[18] = (!hex_freq[26]);
assign pts_controller_0_amphenol_l[17] = (!hex_freq[25]);
assign pts_controller_0_amphenol_l[16] = (!hex_freq[24]);
assign pts_controller_0_amphenol_l[26] = (!hex_freq[23]);
assign pts_controller_0_amphenol_l[25] = (!hex_freq[22]);
assign pts_controller_0_amphenol_l[1] = (!hex_freq[21]);
assign pts_controller_0_amphenol_l[0] = (!hex_freq[20]);
assign pts_controller_0_amphenol_l[28] = (!hex_freq[19]);
assign pts_controller_0_amphenol_l[27] = (!hex_freq[18]);
assign pts_controller_0_amphenol_l[3] = (!hex_freq[17]);
assign pts_controller_0_amphenol_l[2] = (!hex_freq[16]);
assign pts_controller_0_amphenol_l[30] = (!hex_freq[15]);
assign pts_controller_0_amphenol_l[29] = (!hex_freq[14]);
assign pts_controller_0_amphenol_l[5] = (!hex_freq[13]);
assign pts_controller_0_amphenol_l[4] = (!hex_freq[12]);
assign pts_controller_0_amphenol_l[32] = (!hex_freq[11]);
assign pts_controller_0_amphenol_l[31] = (!hex_freq[10]);
assign pts_controller_0_amphenol_l[7] = (!hex_freq[9]);
assign pts_controller_0_amphenol_l[6] = (!hex_freq[8]);
assign pts_controller_0_amphenol_l[34] = (!hex_freq[7]);
assign pts_controller_0_amphenol_l[33] = (!hex_freq[6]);
assign pts_controller_0_amphenol_l[9] = (!hex_freq[5]);
assign pts_controller_0_amphenol_l[8] = (!hex_freq[4]);
assign pts_controller_0_amphenol_l[36] = (!hex_freq[3]);
assign pts_controller_0_amphenol_l[35] = (!hex_freq[2]);
assign pts_controller_0_amphenol_l[11] = (!hex_freq[1]);
assign pts_controller_0_amphenol_l[10] = (!hex_freq[0]);
assign pts_controller_0_amphenol_l[38] = 0;
assign pts_controller_0_amphenol_l[37] = 1;
assign pts_controller_0_amphenol_l[13] = 1;
assign pts_controller_0_amphenol_l[12] = 1;

endmodule
